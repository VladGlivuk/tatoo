import * as i0 from '@angular/core';
import { Component, ChangeDetectionStrategy, ViewChild, Input, HostListener, NgModule, EventEmitter, Output, Directive, ContentChildren } from '@angular/core';
import { Texture, WebGLRenderer, Scene, Clock, Vector2, Raycaster, PerspectiveCamera, TextureLoader, LinearFilter, RGBAFormat, RawShaderMaterial, InstancedBufferGeometry, BufferAttribute, InstancedBufferAttribute, Mesh, Object3D, PlaneGeometry, MeshBasicMaterial, PlaneBufferGeometry, ShaderMaterial, DoubleSide, Vector4, Quaternion, Euler, Group, Vector3 } from 'three';
import { Observable, interval, Subscription, Subject, of, zip, NEVER } from 'rxjs';
import * as i1$1 from '@angular/animations';
import { trigger, transition, style, animate, query, stagger, state } from '@angular/animations';
import * as i2 from '@angular/common';
import { CommonModule } from '@angular/common';
import { switchMap, delay, tap } from 'rxjs/operators';
import { ComponentPortal } from '@angular/cdk/portal';
import * as i1 from '@angular/cdk/overlay';
import { OverlayModule } from '@angular/cdk/overlay';
import { CSS3DRenderer, CSS3DObject } from 'three/examples/jsm/renderers/CSS3DRenderer';

class TouchTexture {
    constructor() {
        this.size = 64;
        this.maxAge = 120;
        this.radius = 0.15;
        this.trail = new Array();
        this.initTexture();
    }
    /**
     * Initializes the texture for the touch area
     */
    initTexture() {
        this.canvas = document.createElement('canvas');
        this.canvas.width = this.canvas.height = this.size;
        this.ctx = this.canvas.getContext('2d');
        this.ctx.fillStyle = 'black';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.texture = new Texture(this.canvas);
        this.canvas.id = 'touchTexture';
        this.canvas.style.width = this.canvas.style.height = `${this.canvas.width}px`;
    }
    /**
     * Updates the trail
     */
    update() {
        this.clear();
        // age points
        this.trail.forEach((point, i) => {
            point.age++;
            // remove old
            if (point.age > this.maxAge) {
                this.trail.splice(i, 1);
            }
        });
        this.trail.forEach((point, i) => {
            this.drawTouch(point);
        });
        this.texture.needsUpdate = true;
    }
    clear() {
        this.ctx.fillStyle = 'black';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }
    addTouch(px, py) {
        let force = 0;
        const last = this.trail[this.trail.length - 1];
        if (last) {
            const dx = last.x - px;
            const dy = last.y - py;
            const dd = dx * dx + dy * dy;
            force = Math.min(dd * 10000, 1);
        }
        this.trail.push({ x: px, y: py, age: 0, force });
    }
    drawTouch(point) {
        const pos = {
            x: point.x * this.size,
            y: (1 - point.y) * this.size
        };
        let intensity = 1;
        if (point.age < this.maxAge * 0.3) {
            intensity = this.easeOutSine(point.age / (this.maxAge * 0.3), 0, 1, 1);
        }
        else {
            intensity = this.easeOutSine(1 - (point.age - this.maxAge * 0.3) / (this.maxAge * 0.7), 0, 1, 1);
        }
        intensity *= point.force;
        const radius = this.size * this.radius * intensity;
        const grd = this.ctx.createRadialGradient(pos.x, pos.y, radius * 0.25, pos.x, pos.y, radius);
        grd.addColorStop(0, `rgba(255, 255, 255, 0.2)`);
        grd.addColorStop(1, 'rgba(0, 0, 0, 0.0)');
        this.ctx.beginPath();
        this.ctx.fillStyle = grd;
        this.ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
        this.ctx.fill();
    }
    easeOutSine(t, b, c, d) {
        return c * Math.sin(t / d * (Math.PI / 2)) + b;
    }
}

class Shaders {
    constructor() {
        this.particleVertex = `
    // @author brunoimbrizi / http://brunoimbrizi.com

    precision highp float;
    #define GLSLIFY 1

    attribute float pindex;
    attribute vec3 position;
    attribute vec3 offset;
    attribute vec2 uv;
    attribute float angle;

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    uniform float uTime;
    uniform float uRandom;
    uniform float uDepth;
    uniform float uSize;
    uniform vec2 uTextureSize;
    uniform sampler2D uTexture;
    uniform sampler2D uTouch;

    varying vec2 vPUv;
    varying vec2 vUv;

    //
    // Description : Array and textureless GLSL 2D simplex noise function.
    //      Author : Ian McEwan, Ashima Arts.
    //  Maintainer : ijm
    //     Lastmod : 20110822 (ijm)
    //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
    //               Distributed under the MIT License. See LICENSE file.
    //               https://github.com/ashima/webgl-noise
    //

    vec3 mod289_1_0(vec3 x) {
      return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec2 mod289_1_0(vec2 x) {
      return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec3 permute_1_1(vec3 x) {
      return mod289_1_0(((x*34.0)+1.0)*x);
    }

    float snoise_1_2(vec2 v)
      {
      const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                          0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                         -0.577350269189626,  // -1.0 + 2.0 * C.x
                          0.024390243902439); // 1.0 / 41.0
    // First corner
      vec2 i  = floor(v + dot(v, C.yy) );
      vec2 x0 = v -   i + dot(i, C.xx);

    // Other corners
      vec2 i1;
      //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
      //i1.y = 1.0 - i1.x;
      i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
      // x0 = x0 - 0.0 + 0.0 * C.xx ;
      // x1 = x0 - i1 + 1.0 * C.xx ;
      // x2 = x0 - 1.0 + 2.0 * C.xx ;
      vec4 x12 = x0.xyxy + C.xxzz;
      x12.xy -= i1;

     // Permutations
      i = mod289_1_0(i); // Avoid truncation effects in permutation
      vec3 p = permute_1_1( permute_1_1( i.y + vec3(0.0, i1.y, 1.0 ))
        + i.x + vec3(0.0, i1.x, 1.0 ));

      vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
      m = m*m ;
      m = m*m ;

    // Gradients: 41 points uniformly over a line, mapped onto a diamond.
    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

      vec3 x = 2.0 * fract(p * C.www) - 1.0;
      vec3 h = abs(x) - 0.5;
      vec3 ox = floor(x + 0.5);
      vec3 a0 = x - ox;

    // Normalise gradients implicitly by scaling m
    // Approximation of: m *= inversesqrt( a0*a0 + h*h );
      m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

    // Compute final noise value at P
      vec3 g;
      g.x  = a0.x  * x0.x  + h.x  * x0.y;
      g.yz = a0.yz * x12.xz + h.yz * x12.yw;
      return 130.0 * dot(m, g);
    }

    float random(float n) {
      return fract(sin(n) * 43758.5453123);
    }

    void main() {
      vUv = uv;

      // particle uv
      vec2 puv = offset.xy / uTextureSize;
      vPUv = puv;

      // pixel color
      vec4 colA = texture2D(uTexture, puv);
      float grey = colA.r * 0.21 + colA.g * 0.71 + colA.b * 0.07;

      // displacement
      vec3 displaced = offset;
      // randomise
      displaced.xy += vec2(random(pindex) - 0.5, random(offset.x + pindex) - 0.5) * uRandom;
      float rndz = (random(pindex) + snoise_1_2(vec2(pindex * 0.1, uTime * 0.1)));
      displaced.z += rndz * (random(pindex) * 2.0 * uDepth);
      // center
      displaced.xy -= uTextureSize * 0.5;

      // touch
      float t = texture2D(uTouch, puv).r;
      displaced.z += t * 20.0 * rndz;
      displaced.x += cos(angle) * t * 20.0 * rndz;
      displaced.y += sin(angle) * t * 20.0 * rndz;

      // particle size
      float psize = (snoise_1_2(vec2(uTime, pindex) * 0.5) + 2.0);
      psize *= max(grey, 0.2);
      psize *= uSize;

      // final position
      vec4 mvPosition = modelViewMatrix * vec4(displaced, 1.0);
      mvPosition.xyz += position * psize;
      vec4 finalPosition = projectionMatrix * mvPosition;

      gl_Position = finalPosition;
    }
    `;
        this.particleFragment = `
    // @author brunoimbrizi / http://brunoimbrizi.com

    precision highp float;
    #define GLSLIFY 1

    uniform sampler2D uTexture;

    varying vec2 vPUv;
    varying vec2 vUv;

    void main() {
      vec4 color = vec4(0.0);
      vec2 uv = vUv;
      vec2 puv = vPUv;

      // pixel color
      vec4 colA = texture2D(uTexture, puv);

      // greyscale
      float grey = colA.r * 0.21 + colA.g * 0.71 + colA.b * 0.07;
      //vec4 colB = vec4(grey, grey, grey, 1.0);
      vec4 colB = vec4(colA.r, colA.g, colA.b, 1.0);

      // circle
      float border = 0.3;
      float radius = 0.5;
      float dist = radius - distance(uv, vec2(0.5));
      float t = smoothstep(0.0, border, dist);

      // final color
      color = colB;
      color.a = t;

      gl_FragColor = color;
    }
    `;
    }
}

var RxjsTween;
(function (RxjsTween) {
    function createTween(easingFunction, b, c, d, s) {
        return new Observable((observer) => {
            let startTime;
            const sample = (time) => {
                startTime = startTime || time;
                const t = time - startTime;
                if (t < d) {
                    if (Array.isArray(b) && Array.isArray(c)) {
                        const tweenVals = new Array();
                        for (let idx = 0; idx < b.length; idx++) {
                            tweenVals.push(easingFunction(t, b[idx], c[idx], d, s));
                        }
                        observer.next(tweenVals);
                    }
                    else {
                        observer.next(easingFunction(t, b, c, d, s));
                    }
                    // Request the animation frame again
                    requestAnimationFrame(sample);
                }
                else {
                    // End value reached
                    if (Array.isArray(b) && Array.isArray(c)) {
                        const tweenVals = new Array();
                        for (let idx = 0; idx < b.length; idx++) {
                            tweenVals.push(c[idx]);
                        }
                        // Emitt end value of arry
                        observer.next(tweenVals);
                    }
                    else {
                        // Emitt end value
                        observer.next(c);
                    }
                    // Complete the observable
                    observer.complete();
                }
            };
            // Initially request the animation frame
            requestAnimationFrame(sample);
        });
    }
    RxjsTween.createTween = createTween;
    function linear(t, b, pc, d) {
        const c = pc - b;
        return c * t / d + b;
    }
    RxjsTween.linear = linear;
    function easeInOutQuad(t, b, pc, d) {
        const c = pc - b;
        if ((t /= d / 2) < 1) {
            return c / 2 * t * t + b;
        }
        else {
            return -c / 2 * ((--t) * (t - 2) - 1) + b;
        }
    }
    RxjsTween.easeInOutQuad = easeInOutQuad;
})(RxjsTween || (RxjsTween = {}));

class PerformanceMonitorComponent {
    constructor(changeDetector) {
        this.changeDetector = changeDetector;
        this.fps = -1;
        this.fpsMin = -1;
        this.fpsMax = -1;
        this.framesCnt = 0;
        this.timeLastFpsCalc = 0;
        this.fpsHistory = new Array();
        this.maxHistoryLength = 60;
    }
    /**
     * Method to be called at the end of a frame
     */
    end() {
        // When called the first time, set the current time and return
        if (this.timeLastFpsCalc === 0) {
            this.timeLastFpsCalc = Date.now();
            return;
        }
        // Increase the frames counter
        this.framesCnt++;
        // Get the milliseconds elapsed since January 1, 1970 for the current frame 
        const currentFrameTime = Date.now();
        // Calculate the FPS only every second
        if (currentFrameTime >= this.timeLastFpsCalc + 1000) {
            // Calculate the frames per second
            this.fps = this.framesCnt / (currentFrameTime - this.timeLastFpsCalc) * 1000;
            // Calculate the min. frames per second
            if (this.fpsMin === -1 || this.fps < this.fpsMin) {
                this.fpsMin = this.fps;
            }
            // Calculate the max. frames per second
            if (this.fpsMax === -1 || this.fps > this.fpsMax) {
                this.fpsMax = this.fps;
            }
            // Trigger the change detection
            this.changeDetector.detectChanges();
            // Set the elapsed time to the timeLastFpsCalc
            this.timeLastFpsCalc = currentFrameTime;
            // Reset the frames counter
            this.framesCnt = 0;
            // Add fps to the history array
            this.fpsHistory.push(this.fps);
            if (this.fpsHistory.length >= this.maxHistoryLength) {
                this.fpsHistory.shift();
            }
            // Create / Update chart
            const canvasEl = this.chart.nativeElement;
            const ctx = canvasEl.getContext('2d');
            if (ctx) {
                ctx.fillStyle = 'rgb(30, 30, 30)';
                ctx.fillRect(0, 0, canvasEl.width, canvasEl.height);
                ctx.strokeStyle = 'rgb(255, 255, 255)';
                ctx.fillStyle = 'rgb(255, 255, 255)';
                ctx.beginPath();
                ctx.moveTo(0, canvasEl.height);
                for (let idx = 0; idx <= this.fpsHistory.length; idx++) {
                    ctx.lineTo(canvasEl.width / this.maxHistoryLength * idx, canvasEl.height - (this.fpsHistory[idx] / this.fpsMax * canvasEl.height));
                    if (idx === this.fpsHistory.length - 1) {
                        ctx.lineTo(canvasEl.width / this.maxHistoryLength * idx, canvasEl.height);
                    }
                }
                ctx.fill();
            }
        }
    }
}
PerformanceMonitorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: PerformanceMonitorComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
PerformanceMonitorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.1", type: PerformanceMonitorComponent, selector: "acuw-performance-monitor", viewQueries: [{ propertyName: "chart", first: true, predicate: ["chart"], descendants: true }], ngImport: i0, template: "<div id=\"pm-container\">\r\n    <div id=\"fps-display-container\">\r\n        <span id=\"fps-display\">FPS: {{ fps != -1 ? (fps | number: '1.0-0') : '-' }}</span>\r\n        <div id=\"min-max-display\">\r\n            <span id=\"max-fps-display\">{{ fpsMax != -1 ? (fpsMax | number: '1.0-0') : '-' }} max</span>\r\n            <span id=\"min-fps-display\">{{ fpsMin != -1 ? (fpsMin | number: '1.0-0') : '-' }} min</span>\r\n        </div>\r\n    </div>\r\n    <canvas #chart width=\"90\" height=\"40\"></canvas>\r\n</div>", styles: [":host{--position: absolute;--color: rgb(255, 255, 255);--background-color: rgba(0, 0, 0, .8);--top: 5px;--left: 5px;--width: 100px;--padding: 5px;--display: flex;--flex-direction: column;--align-items: center}#pm-container{position:var(--position);color:var(--color);background-color:var(--background-color);top:5px;left:5px;width:100px;padding:5px;display:var(--display);flex-direction:var(--flex-direction);align-items:var(--align-items)}#fps-display-container{display:flex;flex-direction:row;align-items:center}#min-max-display{display:flex;flex-direction:column;font-size:10px;padding-left:5px}\n"], pipes: { "number": i2.DecimalPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: PerformanceMonitorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'acuw-performance-monitor', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div id=\"pm-container\">\r\n    <div id=\"fps-display-container\">\r\n        <span id=\"fps-display\">FPS: {{ fps != -1 ? (fps | number: '1.0-0') : '-' }}</span>\r\n        <div id=\"min-max-display\">\r\n            <span id=\"max-fps-display\">{{ fpsMax != -1 ? (fpsMax | number: '1.0-0') : '-' }} max</span>\r\n            <span id=\"min-fps-display\">{{ fpsMin != -1 ? (fpsMin | number: '1.0-0') : '-' }} min</span>\r\n        </div>\r\n    </div>\r\n    <canvas #chart width=\"90\" height=\"40\"></canvas>\r\n</div>", styles: [":host{--position: absolute;--color: rgb(255, 255, 255);--background-color: rgba(0, 0, 0, .8);--top: 5px;--left: 5px;--width: 100px;--padding: 5px;--display: flex;--flex-direction: column;--align-items: center}#pm-container{position:var(--position);color:var(--color);background-color:var(--background-color);top:5px;left:5px;width:100px;padding:5px;display:var(--display);flex-direction:var(--flex-direction);align-items:var(--align-items)}#fps-display-container{display:flex;flex-direction:row;align-items:center}#min-max-display{display:flex;flex-direction:column;font-size:10px;padding-left:5px}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { chart: [{
                type: ViewChild,
                args: ['chart']
            }] } });

class ImageAsParticlesComponent {
    constructor(ngZone) {
        this.ngZone = ngZone;
        // Declare variables
        this.renderer = new WebGLRenderer({
            antialias: true,
            alpha: true,
        });
        this.scene = new Scene();
        this.clock = new Clock(true);
        this.texture = new Texture();
        this.width = 0;
        this.height = 0;
        this.touch = new TouchTexture();
        this.mouse = new Vector2();
        this.raycaster = new Raycaster();
        this.pImageUrl = '';
        this.pImageChanging = false;
        this.gestureInfo$ = interval(2000);
        this.gestureInfoSubscription = new Subscription();
        this.showTouchGestureInfo = false;
        this.justifyContent = 'center';
        this.alignItems = 'center';
        this.backgroundColor = '#000000';
        this.imageWidth = '100%';
        this.imageHeight = '100%';
        this.animationEnabled = true;
        this.showPerformanceMonitor = false;
    }
    // Inputs
    set imageUrl(imageUrl) {
        this.pImageUrl = imageUrl;
        if (this.pImageChanging === true) {
            return;
        }
        if (this.mesh != null) {
            this.pImageChanging = true;
            this.triggerImageChange();
        }
    }
    get imageUrl() {
        return this.pImageUrl;
    }
    set horizontalAlignment(horizontalAlignment) {
        switch (horizontalAlignment) {
            case 'start':
                this.justifyContent = 'flex-start';
                break;
            case 'center':
                this.justifyContent = 'center';
                break;
            case 'end':
                this.justifyContent = 'flex-end';
                break;
            default:
                this.justifyContent = 'center';
                break;
        }
    }
    get horizontalAlignment() {
        return this.justifyContent;
    }
    set verticalAlignment(verticalAlignment) {
        switch (verticalAlignment) {
            case 'top':
                this.alignItems = 'flex-start';
                break;
            case 'center':
                this.alignItems = 'center';
                break;
            case 'bottom':
                this.alignItems = 'flex-end';
                break;
            default:
                this.alignItems = 'center';
                break;
        }
    }
    get verticalAlignment() {
        return this.alignItems;
    }
    ngAfterViewInit() {
        if (this.pImageUrl === '') {
            return;
        }
        const canvasWidth = this.canvasRef.nativeElement.clientWidth;
        const canvasHeight = this.canvasRef.nativeElement.clientHeight;
        // Set camera
        this.camera = new PerspectiveCamera(50, canvasWidth / canvasHeight, 1, 10000);
        this.camera.position.z = 300;
        // Init particles
        this.initParticles(this.pImageUrl);
        // Init renderer
        this.renderer.setSize(canvasWidth - 1, canvasHeight);
        this.canvasRef.nativeElement.appendChild(this.renderer.domElement);
        // Start animation
        this.animate();
    }
    ngOnDestroy() {
        this.scene.clear();
        this.renderer.clear();
        this.texture.dispose();
        this.renderer.dispose();
    }
    /**
     * Creates the particles depending on the image and initializes the touch canvas
     * @param url url of the image
     */
    initParticles(url) {
        const loader = new TextureLoader();
        loader.load(url, (texture) => {
            this.texture = texture;
            this.texture.minFilter = LinearFilter;
            this.texture.magFilter = LinearFilter;
            this.texture.format = RGBAFormat;
            this.width = texture.image.width;
            this.height = texture.image.height;
            this.initPoints(true);
            this.initHitArea();
            this.initTouch();
            this.resize();
            this.show();
        });
    }
    /**
     * Initializes the points
     * @param discard discard pixels darker than threshold #22
     */
    initPoints(discard) {
        const numPoints = this.width * this.height;
        let numVisible = numPoints;
        let threshold = 0;
        let originalColors = new Float32Array();
        if (discard) {
            // discard pixels darker than threshold #22
            numVisible = 0;
            threshold = 34;
            const img = this.texture.image;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = this.width;
            canvas.height = this.height;
            if (ctx != null) {
                ctx.scale(1, -1);
                ctx.drawImage(img, 0, 0, this.width, this.height * -1);
                const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                originalColors = Float32Array.from(imgData.data);
                for (let i = 0; i < numPoints; i++) {
                    if (originalColors[i * 4 + 0] > threshold) {
                        numVisible++;
                    }
                }
            }
        }
        const uniforms = {
            uTime: { value: 0 },
            uRandom: { value: 1.0 },
            uDepth: { value: 2.0 },
            uSize: { value: 0.0 },
            uTextureSize: { value: new Vector2(this.width, this.height) },
            uTexture: { value: this.texture },
            uTouch: { value: null },
        };
        const shaders = new Shaders();
        const material = new RawShaderMaterial({
            uniforms,
            vertexShader: shaders.particleVertex,
            fragmentShader: shaders.particleFragment,
            depthTest: false,
            transparent: true,
            // blending: THREE.AdditiveBlending
        });
        const geometry = new InstancedBufferGeometry();
        // positions
        const positions = new BufferAttribute(new Float32Array(4 * 3), 3);
        positions.setXYZ(0, -0.5, 0.5, 0.0);
        positions.setXYZ(1, 0.5, 0.5, 0.0);
        positions.setXYZ(2, -0.5, -0.5, 0.0);
        positions.setXYZ(3, 0.5, -0.5, 0.0);
        geometry.setAttribute('position', positions);
        // uvs
        const uvs = new BufferAttribute(new Float32Array(4 * 2), 2);
        uvs.setXY(0, 0.0, 0.0);
        uvs.setXY(1, 1.0, 0.0);
        uvs.setXY(2, 0.0, 1.0);
        uvs.setXY(3, 1.0, 1.0);
        geometry.setAttribute('uv', uvs);
        // index
        geometry.setIndex(new BufferAttribute(new Uint16Array([0, 2, 1, 2, 3, 1]), 1));
        const indices = new Uint16Array(numVisible);
        const offsets = new Float32Array(numVisible * 3);
        const angles = new Float32Array(numVisible);
        for (let i = 0, j = 0; i < numPoints; i++) {
            if (discard && originalColors[i * 4 + 0] <= threshold) {
                continue;
            }
            offsets[j * 3 + 0] = i % this.width;
            offsets[j * 3 + 1] = Math.floor(i / this.width);
            indices[j] = i;
            angles[j] = Math.random() * Math.PI;
            j++;
        }
        geometry.setAttribute('pindex', new InstancedBufferAttribute(indices, 1, false));
        geometry.setAttribute('offset', new InstancedBufferAttribute(offsets, 3, false));
        geometry.setAttribute('angle', new InstancedBufferAttribute(angles, 1, false));
        this.mesh = new Mesh(geometry, material);
        const object3d = new Object3D();
        object3d.add(this.mesh);
        this.scene.add(object3d);
    }
    /**
     * Initializes the touch area
     */
    initTouch() {
        this.mesh.material.uniforms.uTouch.value =
            this.touch.texture;
    }
    /**
     * Initializes the hit area
     */
    initHitArea() {
        const geometry = new PlaneGeometry(this.width, this.height, 1, 1);
        const material = new MeshBasicMaterial({
            color: 0xffffff,
            wireframe: true,
            depthTest: false,
        });
        material.visible = false;
        this.hitArea = new Mesh(geometry, material);
        this.mesh.add(this.hitArea);
    }
    /**
     * animation for showing the particles
     * @param time time of animation in ms
     */
    show(time = 1000) {
        // Tween in
        this.ngZone.runOutsideAngular(() => {
            RxjsTween.createTween(RxjsTween.easeInOutQuad, [0.5, 0.0, 70.0], [1.5, 2.0, 4.0], time).subscribe((val) => {
                this.mesh.material.uniforms.uSize.value =
                    val[0];
                this.mesh.material.uniforms.uRandom.value =
                    val[1];
                this.mesh.material.uniforms.uDepth.value =
                    val[2];
            }, () => { }, () => {
                this.pImageChanging = false;
            });
        });
    }
    /**
     * animation for tween out the particles and destroy everything
     * @param time time of animation in ms
     */
    triggerImageChange(time = 1000) {
        const uSizeStart = this.mesh.material.uniforms.uSize
            .value;
        const uRandomStart = this.mesh.material.uniforms
            .uRandom.value;
        const uDepth = this.mesh.material.uniforms.uDepth
            .value;
        this.ngZone.runOutsideAngular(() => {
            // Tween out
            RxjsTween.createTween(RxjsTween.easeInOutQuad, [uSizeStart, uRandomStart, uDepth], [0.0, 5.0, -20.0], time).subscribe((val) => {
                this.mesh.material.uniforms.uSize.value =
                    val[0];
                this.mesh.material.uniforms.uRandom.value =
                    val[1];
                this.mesh.material.uniforms.uDepth.value =
                    val[2];
            }, () => { }, () => {
                if (this.mesh != null) {
                    if (this.mesh.parent != null) {
                        this.mesh.parent.remove(this.mesh);
                    }
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                }
                if (this.hitArea != null) {
                    if (this.hitArea.parent != null) {
                        this.hitArea.parent.remove(this.hitArea);
                    }
                    this.hitArea.geometry.dispose();
                    this.hitArea.material.dispose();
                }
                this.initParticles(this.pImageUrl);
                this.pImageChanging = false;
            });
        });
    }
    /**
     * Method for triggering the animation
     */
    animate() {
        this.ngZone.runOutsideAngular(() => {
            window.requestAnimationFrame(() => this.animate());
            if (this.animationEnabled === true) {
                const delta = this.clock.getDelta();
                if (this.mesh != null) {
                    if (this.touch) {
                        this.touch.update();
                    }
                    this.mesh.material.uniforms.uTime.value +=
                        delta;
                }
                this.renderer.render(this.scene, this.camera);
            }
            if (this.performanceMonitor && this.showPerformanceMonitor) {
                this.performanceMonitor.end();
            }
        });
    }
    /**
     * Handle mouse move event
     * @param event mouse event
     */
    onMouseMove(event) {
        // getBoundingClientRect retruns the distance in pixels of the top left corner of the element
        // to the top left corner of the viewport
        const domRect = this.canvasRef.nativeElement.getBoundingClientRect();
        // get the offset distance between the canvas, which contains the particles, to the outer container element
        const canvasEl = this.canvasRef.nativeElement
            .children[0];
        // Calculate the relative mouse position
        this.mouse.x =
            ((event.clientX - domRect.left - canvasEl.offsetLeft) /
                canvasEl.clientWidth) *
                2 -
                1;
        this.mouse.y =
            (-(event.clientY - domRect.top - canvasEl.offsetTop) /
                canvasEl.clientHeight) *
                2 +
                1;
        // console.info('raw: x= ' + event.clientX + ' , y= ' + event.clientY);
        // console.info('normalized: x= ' + this.mouse.x + ' , y= ' + this.mouse.y);
        this.raycaster.setFromCamera(this.mouse, this.camera);
        if (this.hitArea === undefined) {
            return;
        }
        const intersects = this.raycaster.intersectObject(this.hitArea);
        if (intersects !== undefined &&
            intersects.length > 0 &&
            this.touch &&
            intersects[0].uv !== undefined) {
            this.touch.addTouch(intersects[0].uv.x, intersects[0].uv.y);
        }
    }
    /**
     * Handle touch move envent
     * @param event mouse event
     */
    onTouchMove(event) {
        if (event.touches.length < 2) {
            this.showTouchGestureInfo = true;
            this.gestureInfoSubscription.unsubscribe();
            this.gestureInfoSubscription = this.gestureInfo$.subscribe({
                next: () => {
                    this.showTouchGestureInfo = false;
                    this.gestureInfoSubscription.unsubscribe();
                },
            });
            return;
        }
        event.preventDefault();
        // getBoundingClientRect retruns the distance in pixels of the top left corner of the element
        // to the top left corner of the viewport
        const domRect = this.canvasRef.nativeElement.getBoundingClientRect();
        // get the offset distance between the canvas, which contains the particles, to the outer container element
        const canvasEl = this.canvasRef.nativeElement
            .children[0];
        // Calculate the relative mouse position
        this.mouse.x =
            ((event.touches[0].clientX - domRect.left - canvasEl.offsetLeft) /
                canvasEl.clientWidth) *
                2 -
                1;
        this.mouse.y =
            (-(event.touches[0].clientY - domRect.top - canvasEl.offsetTop) /
                canvasEl.clientHeight) *
                2 +
                1;
        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObject(this.hitArea);
        if (intersects !== undefined &&
            intersects.length > 0 &&
            this.touch &&
            intersects[0].uv !== undefined) {
            this.touch.addTouch(intersects[0].uv.x, intersects[0].uv.y);
        }
    }
    resize() {
        if (this.height !== undefined) {
            this.camera.aspect =
                this.canvasRef.nativeElement.clientWidth /
                    this.canvasRef.nativeElement.clientHeight;
            this.camera.updateProjectionMatrix();
            const fovHeight = 2 *
                Math.tan((this.camera.fov * Math.PI) / 180 / 2) *
                this.camera.position.z;
            const scale = fovHeight / this.height;
            this.mesh.scale.set(scale, scale, 1);
            // this.hitArea.scale.set(scale, scale, 1);
            if (this.renderer !== undefined) {
                const width = this.imageWidth == null
                    ? this.canvasRef.nativeElement.clientWidth
                    : this.distanceAsNumber(this.imageWidth, this.canvasRef.nativeElement.clientWidth);
                const height = this.imageHeight == null
                    ? this.canvasRef.nativeElement.clientHeight
                    : this.distanceAsNumber(this.imageHeight, this.canvasRef.nativeElement.clientHeight);
                this.renderer.setSize(width, height);
            }
        }
    }
    distanceAsNumber(distance, parentDistance) {
        let returnVal = 0;
        if (distance.includes('px')) {
            returnVal = Number.parseInt(distance.replace('px', ''), 10);
        }
        else if (distance.includes('%')) {
            returnVal =
                (Number.parseInt(distance.replace('%', ''), 10) / 100) * parentDistance;
        }
        else {
            returnVal = Number.parseInt(distance, 10);
        }
        return returnVal;
    }
}
ImageAsParticlesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: ImageAsParticlesComponent, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
ImageAsParticlesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.1", type: ImageAsParticlesComponent, selector: "lib-image-as-particles", inputs: { imageUrl: "imageUrl", backgroundColor: "backgroundColor", imageWidth: "imageWidth", imageHeight: "imageHeight", horizontalAlignment: "horizontalAlignment", verticalAlignment: "verticalAlignment", animationEnabled: "animationEnabled", showPerformanceMonitor: "showPerformanceMonitor" }, host: { listeners: { "window:resize": "resize()" } }, viewQueries: [{ propertyName: "canvasRef", first: true, predicate: ["container"], descendants: true }, { propertyName: "performanceMonitor", first: true, predicate: ["performanceMonitor"], descendants: true }], ngImport: i0, template: `
    <div
      #container
      class="threejs-container"
      [style.background-color]="backgroundColor"
      [style.justify-content]="justifyContent"
      [style.align-items]="alignItems"
      (mousemove)="onMouseMove($event)"
      (touchmove)="onTouchMove($event)"
    ></div>
    <div
      *ngIf="showTouchGestureInfo == true"
      class="touch-gesture-info"
      [@showHideGestureInformation]
    >
      <div>
        <span>Use two fingers for touch animation</span>
        <svg
          xmlns="http://www.w3.org/2000/svg"
          enable-background="new 0 0 24 24"
          viewBox="0 0 24 24"
          fill="white"
          width="18px"
          height="18px"
        >
          <g><rect fill="none" height="24" width="24" x="0" /></g>
          <g>
            <g>
              <g>
                <path
                  d="M9,11.24V7.5C9,6.12,10.12,5,11.5,5S14,6.12,14,7.5v3.74c1.21-0.81,2-2.18,2-3.74C16,5.01,13.99,3,11.5,3S7,5.01,7,7.5 C7,9.06,7.79,10.43,9,11.24z M18.84,15.87l-4.54-2.26c-0.17-0.07-0.35-0.11-0.54-0.11H13v-6C13,6.67,12.33,6,11.5,6 S10,6.67,10,7.5v10.74c-3.6-0.76-3.54-0.75-3.67-0.75c-0.31,0-0.59,0.13-0.79,0.33l-0.79,0.8l4.94,4.94 C9.96,23.83,10.34,24,10.75,24h6.79c0.75,0,1.33-0.55,1.44-1.28l0.75-5.27c0.01-0.07,0.02-0.14,0.02-0.2 C19.75,16.63,19.37,16.09,18.84,15.87z"
                />
              </g>
            </g>
          </g>
        </svg>
      </div>
    </div>
    <acuw-performance-monitor
      *ngIf="showPerformanceMonitor"
      #performanceMonitor
    ></acuw-performance-monitor>
  `, isInline: true, styles: [".threejs-container{position:relative;display:flex;justify-content:center;align-items:center;width:100%;height:100%;background-color:#222}.touch-gesture-info{position:absolute;width:100%;display:flex;flex-direction:row;justify-content:center;top:20px;color:#fff}.touch-gesture-info div{background-color:#0000004d;display:flex;flex-direction:row;padding:6px 10px;border-radius:5px}\n"], components: [{ type: PerformanceMonitorComponent, selector: "acuw-performance-monitor" }], directives: [{ type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], animations: [
        trigger('showHideGestureInformation', [
            transition(':enter', [
                style({ opacity: '0' }),
                animate('300ms ease-in', style({ opacity: '1' })),
            ]),
            transition(':leave', [
                style({ opacity: '1' }),
                animate('300ms ease-in', style({ opacity: '0' })),
            ]),
        ]),
    ] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: ImageAsParticlesComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'lib-image-as-particles',
                    template: `
    <div
      #container
      class="threejs-container"
      [style.background-color]="backgroundColor"
      [style.justify-content]="justifyContent"
      [style.align-items]="alignItems"
      (mousemove)="onMouseMove($event)"
      (touchmove)="onTouchMove($event)"
    ></div>
    <div
      *ngIf="showTouchGestureInfo == true"
      class="touch-gesture-info"
      [@showHideGestureInformation]
    >
      <div>
        <span>Use two fingers for touch animation</span>
        <svg
          xmlns="http://www.w3.org/2000/svg"
          enable-background="new 0 0 24 24"
          viewBox="0 0 24 24"
          fill="white"
          width="18px"
          height="18px"
        >
          <g><rect fill="none" height="24" width="24" x="0" /></g>
          <g>
            <g>
              <g>
                <path
                  d="M9,11.24V7.5C9,6.12,10.12,5,11.5,5S14,6.12,14,7.5v3.74c1.21-0.81,2-2.18,2-3.74C16,5.01,13.99,3,11.5,3S7,5.01,7,7.5 C7,9.06,7.79,10.43,9,11.24z M18.84,15.87l-4.54-2.26c-0.17-0.07-0.35-0.11-0.54-0.11H13v-6C13,6.67,12.33,6,11.5,6 S10,6.67,10,7.5v10.74c-3.6-0.76-3.54-0.75-3.67-0.75c-0.31,0-0.59,0.13-0.79,0.33l-0.79,0.8l4.94,4.94 C9.96,23.83,10.34,24,10.75,24h6.79c0.75,0,1.33-0.55,1.44-1.28l0.75-5.27c0.01-0.07,0.02-0.14,0.02-0.2 C19.75,16.63,19.37,16.09,18.84,15.87z"
                />
              </g>
            </g>
          </g>
        </svg>
      </div>
    </div>
    <acuw-performance-monitor
      *ngIf="showPerformanceMonitor"
      #performanceMonitor
    ></acuw-performance-monitor>
  `,
                    styles: [
                        `
      .threejs-container {
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        height: 100%;
        background-color: #222222;
      }

      .touch-gesture-info {
        position: absolute;
        width: 100%;
        display: flex;
        flex-direction: row;
        justify-content: center;
        top: 20px;
        color: white;
      }

      .touch-gesture-info div {
        background-color: rgba(0, 0, 0, 0.3);
        display: flex;
        flex-direction: row;
        padding: 6px 10px 6px 10px;
        border-radius: 5px;
      }
    `,
                    ],
                    animations: [
                        trigger('showHideGestureInformation', [
                            transition(':enter', [
                                style({ opacity: '0' }),
                                animate('300ms ease-in', style({ opacity: '1' })),
                            ]),
                            transition(':leave', [
                                style({ opacity: '1' }),
                                animate('300ms ease-in', style({ opacity: '0' })),
                            ]),
                        ]),
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }]; }, propDecorators: { imageUrl: [{
                type: Input
            }], backgroundColor: [{
                type: Input
            }], imageWidth: [{
                type: Input
            }], imageHeight: [{
                type: Input
            }], horizontalAlignment: [{
                type: Input
            }], verticalAlignment: [{
                type: Input
            }], animationEnabled: [{
                type: Input
            }], showPerformanceMonitor: [{
                type: Input
            }], canvasRef: [{
                type: ViewChild,
                args: ['container']
            }], performanceMonitor: [{
                type: ViewChild,
                args: ['performanceMonitor']
            }], resize: [{
                type: HostListener,
                args: ['window:resize']
            }] } });

class PerformanceMonitorModule {
}
PerformanceMonitorModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: PerformanceMonitorModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PerformanceMonitorModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: PerformanceMonitorModule, declarations: [PerformanceMonitorComponent], imports: [CommonModule], exports: [PerformanceMonitorComponent] });
PerformanceMonitorModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: PerformanceMonitorModule, imports: [[
            CommonModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: PerformanceMonitorModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        PerformanceMonitorComponent
                    ],
                    imports: [
                        CommonModule
                    ],
                    exports: [
                        PerformanceMonitorComponent
                    ]
                }]
        }] });

class ImageAsParticlesModule {
}
ImageAsParticlesModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: ImageAsParticlesModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ImageAsParticlesModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: ImageAsParticlesModule, declarations: [ImageAsParticlesComponent], imports: [CommonModule, PerformanceMonitorModule], exports: [ImageAsParticlesComponent] });
ImageAsParticlesModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: ImageAsParticlesModule, imports: [[
            CommonModule, PerformanceMonitorModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: ImageAsParticlesModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [ImageAsParticlesComponent],
                    imports: [
                        CommonModule, PerformanceMonitorModule
                    ],
                    exports: [ImageAsParticlesComponent]
                }]
        }] });

var Direction;
(function (Direction) {
    Direction[Direction["forward"] = 0] = "forward";
    Direction[Direction["backward"] = 1] = "backward";
})(Direction || (Direction = {}));

class ImageTransitionShaders {
    constructor() {
        this.vertex = `varying vec2 vUv;void main() {vUv = uv;gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );}`;
        this.splitTransitionFrag = `
            uniform float progress;
            uniform float intensity;
            uniform sampler2D texture1;
            uniform sampler2D texture2;
            uniform vec4 resolution1;
            uniform vec4 resolution2;
            varying vec2 vUv;
            mat2 rotate(float a) {
              float s = sin(a);
              float c = cos(a);
              return mat2(c, -s, s, c);
            }
            void main()	{
              vec2 newUV1 = (vUv - vec2(0.5,0.5))*resolution1.zw + vec2(0.5,0.5);
              vec2 newUV2 = (vUv - vec2(0.5,0.5))*resolution2.zw + vec2(0.5,0.5);
              vec2 uvDivided1 = fract(newUV1*vec2(intensity,1.));
              vec2 uvDivided2 = fract(newUV2*vec2(intensity,1.));
              vec2 uvDisplaced1 = newUV1 + rotate(3.1415926/4.)*uvDivided1*progress*0.1;
              vec2 uvDisplaced2 = newUV2 + rotate(3.1415926/4.)*uvDivided2*(1. - progress)*0.1;
              vec4 t1 = texture2D(texture1,uvDisplaced1);
              vec4 t2 = texture2D(texture2,uvDisplaced2);
              // Use black background color
              // Top right
              vec2 tr1 = step(newUV1, vec2(1.0, 1.0));
              vec2 tr2 = step(newUV2, vec2(1.0, 1.0));
              float pct1 = tr1.x * tr1.y;
              float pct2 = tr2.x * tr2.y;
              // Bottom left
              vec2 bl1 = step(vec2(0.0, 0.0), newUV1);
              vec2 bl2 = step(vec2(0.0, 0.0), newUV2);
              pct1 *= bl1.x * bl1.y;
              pct2 *= bl2.x * bl2.y;
              vec4 t1wb = t1 * vec4(pct1,pct1,pct1,1.0);
              vec4 t2wb = t2 * vec4(pct2,pct2,pct2,1.0);
              gl_FragColor = mix(t1wb, t2wb, progress);
            }
    `;
        this.fadeFrag = `
            uniform float progress;
            uniform sampler2D texture1;
            uniform sampler2D texture2;
            uniform vec4 resolution1;
            uniform vec4 resolution2;
            varying vec2 vUv;
            mat2 rotate(float a) {
              float s = sin(a);
              float c = cos(a);
              return mat2(c, -s, s, c);
            }
            void main()	{
              vec2 newUV1 = (vUv - vec2(0.5,0.5))*resolution1.zw + vec2(0.5,0.5);
              vec2 newUV2 = (vUv - vec2(0.5,0.5))*resolution2.zw + vec2(0.5,0.5);
              vec2 uvDisplaced1 = newUV1 + vec2(1.0,0)*progress*0.1;
              vec2 uvDisplaced2 = newUV2 + vec2(1.0,0)*(1. - progress)*0.1;
              vec4 t1 = texture2D(texture1,uvDisplaced1);
              vec4 t2 = texture2D(texture2,uvDisplaced2);
              // Use black background color
              // Top right
              vec2 tr1 = step(newUV1, vec2(1.0, 1.0));
              vec2 tr2 = step(newUV2, vec2(1.0, 1.0));
              float pct1 = tr1.x * tr1.y;
              float pct2 = tr2.x * tr2.y;
              // Bottom left
              vec2 bl1 = step(vec2(0.0, 0.0), newUV1);
              vec2 bl2 = step(vec2(0.0, 0.0), newUV2);
              pct1 *= bl1.x * bl1.y;
              pct2 *= bl2.x * bl2.y;
              vec4 t1wb = t1 * vec4(pct1,pct1,pct1,1.0);
              vec4 t2wb = t2 * vec4(pct2,pct2,pct2,1.0);
              gl_FragColor = mix(t1wb, t2wb, progress);
            }
    `;
        this.noiseFrag = `
		uniform float time;
		uniform float progress;
		uniform float width;
		uniform float scaleX;
		uniform float scaleY;
		uniform sampler2D texture1;
		uniform sampler2D texture2;
		uniform sampler2D displacement;
		uniform vec4 resolution1;
		uniform vec4 resolution2;
		varying vec2 vUv;
		varying vec4 vPosition;
		//	Classic Perlin 3D Noise
		//	by Stefan Gustavson
		//
		vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
		vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
		vec4 fade(vec4 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}
		float cnoise(vec4 P){
		  ;
		  vec4 Pi0 = floor(P); // Integer part for indexing
		  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1
		  Pi0 = mod(Pi0, 289.0);
		  Pi1 = mod(Pi1, 289.0);
		  vec4 Pf0 = fract(P); // Fractional part for interpolation
		  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0
		  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		  vec4 iy = vec4(Pi0.yy, Pi1.yy);
		  vec4 iz0 = vec4(Pi0.zzzz);
		  vec4 iz1 = vec4(Pi1.zzzz);
		  vec4 iw0 = vec4(Pi0.wwww);
		  vec4 iw1 = vec4(Pi1.wwww);
		  vec4 ixy = permute(permute(ix) + iy);
		  vec4 ixy0 = permute(ixy + iz0);
		  vec4 ixy1 = permute(ixy + iz1);
		  vec4 ixy00 = permute(ixy0 + iw0);
		  vec4 ixy01 = permute(ixy0 + iw1);
		  vec4 ixy10 = permute(ixy1 + iw0);
		  vec4 ixy11 = permute(ixy1 + iw1);
		  vec4 gx00 = ixy00 / 7.0;
		  vec4 gy00 = floor(gx00) / 7.0;
		  vec4 gz00 = floor(gy00) / 6.0;
		  gx00 = fract(gx00) - 0.5;
		  gy00 = fract(gy00) - 0.5;
		  gz00 = fract(gz00) - 0.5;
		  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
		  vec4 sw00 = step(gw00, vec4(0.0));
		  gx00 -= sw00 * (step(0.0, gx00) - 0.5);
		  gy00 -= sw00 * (step(0.0, gy00) - 0.5);
		  vec4 gx01 = ixy01 / 7.0;
		  vec4 gy01 = floor(gx01) / 7.0;
		  vec4 gz01 = floor(gy01) / 6.0;
		  gx01 = fract(gx01) - 0.5;
		  gy01 = fract(gy01) - 0.5;
		  gz01 = fract(gz01) - 0.5;
		  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
		  vec4 sw01 = step(gw01, vec4(0.0));
		  gx01 -= sw01 * (step(0.0, gx01) - 0.5);
		  gy01 -= sw01 * (step(0.0, gy01) - 0.5);
		  vec4 gx10 = ixy10 / 7.0;
		  vec4 gy10 = floor(gx10) / 7.0;
		  vec4 gz10 = floor(gy10) / 6.0;
		  gx10 = fract(gx10) - 0.5;
		  gy10 = fract(gy10) - 0.5;
		  gz10 = fract(gz10) - 0.5;
		  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
		  vec4 sw10 = step(gw10, vec4(0.0));
		  gx10 -= sw10 * (step(0.0, gx10) - 0.5);
		  gy10 -= sw10 * (step(0.0, gy10) - 0.5);
		  vec4 gx11 = ixy11 / 7.0;
		  vec4 gy11 = floor(gx11) / 7.0;
		  vec4 gz11 = floor(gy11) / 6.0;
		  gx11 = fract(gx11) - 0.5;
		  gy11 = fract(gy11) - 0.5;
		  gz11 = fract(gz11) - 0.5;
		  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
		  vec4 sw11 = step(gw11, vec4(0.0));
		  gx11 -= sw11 * (step(0.0, gx11) - 0.5);
		  gy11 -= sw11 * (step(0.0, gy11) - 0.5);
		  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);
		  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);
		  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);
		  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);
		  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);
		  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);
		  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);
		  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);
		  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);
		  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);
		  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);
		  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);
		  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);
		  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);
		  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);
		  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);
		  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
		  g0000 *= norm00.x;
		  g0100 *= norm00.y;
		  g1000 *= norm00.z;
		  g1100 *= norm00.w;
		  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
		  g0001 *= norm01.x;
		  g0101 *= norm01.y;
		  g1001 *= norm01.z;
		  g1101 *= norm01.w;
		  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
		  g0010 *= norm10.x;
		  g0110 *= norm10.y;
		  g1010 *= norm10.z;
		  g1110 *= norm10.w;
		  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
		  g0011 *= norm11.x;
		  g0111 *= norm11.y;
		  g1011 *= norm11.z;
		  g1111 *= norm11.w;
		  float n0000 = dot(g0000, Pf0);
		  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));
		  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));
		  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));
		  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));
		  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
		  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));
		  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));
		  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));
		  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));
		  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
		  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));
		  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));
		  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));
		  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));
		  float n1111 = dot(g1111, Pf1);
		  vec4 fade_xyzw = fade(Pf0);
		  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);
		  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);
		  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);
		  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);
		  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
		  return 2.2 * n_xyzw;
		}
		float map(float value, float min1, float max1, float min2, float max2) {
		  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
		}
		float parabola( float x, float k ) {
		  return pow( 4. * x * ( 1. - x ), k );
		}
		void main()	{
			float dt = parabola(progress,1.);
			float border = 1.;
			vec2 newUV1 = (vUv - vec2(0.5,0.5))*resolution1.zw + vec2(0.5,0.5);
      		vec2 newUV2 = (vUv - vec2(0.5,0.5))*resolution2.zw + vec2(0.5,0.5);
			vec4 t1 = texture2D(texture1,newUV1);
      		vec4 t2 = texture2D(texture2,newUV2);
      		// Use black background color
      		// Top right
      		vec2 tr1 = step(newUV1, vec2(1.0, 1.0));
      		vec2 tr2 = step(newUV2, vec2(1.0, 1.0));
      		float pct1 = tr1.x * tr1.y;
      		float pct2 = tr2.x * tr2.y;
      		// Bottom left
      		vec2 bl1 = step(vec2(0.0, 0.0), newUV1);
      		vec2 bl2 = step(vec2(0.0, 0.0), newUV2);
      		pct1 *= bl1.x * bl1.y;
      		pct2 *= bl2.x * bl2.y;
      		vec4 t1wb = t1 * vec4(pct1,pct1,pct1,1.0);
      		vec4 t2wb = t2 * vec4(pct2,pct2,pct2,1.0);
			float realnoise = 0.5*(cnoise(vec4(newUV1.x*scaleX  + 0.*time/3., newUV1.y*scaleY,0.*time/3.,0.)) +1.);
			float w = width*dt;
			float maskvalue = smoothstep(1. - w,1.,vUv.x + mix(-w/2., 1. - w/2., progress));
			float mask = maskvalue + maskvalue*realnoise;
			float final = smoothstep(border,border+0.01,mask);
			gl_FragColor = mix(t1wb,t2wb,final);
		}
	`;
        this.blurFrag = `
		// author: gre
		// license: MIT
		uniform float progress;
		uniform float intensity;
		uniform float ratio;
		uniform sampler2D texture1;
		uniform sampler2D texture2;
		uniform vec4 resolution1;
		uniform vec4 resolution2;
		varying vec2 vUv;
		const int passes = 6;

		void main() {
			vec2 newUV1 = (vUv - vec2(0.5,0.5))*resolution1.zw + vec2(0.5,0.5);
			vec2 newUV2 = (vUv - vec2(0.5,0.5))*resolution2.zw + vec2(0.5,0.5);

			vec4 t1 = vec4(0.0);
			vec4 t2 = vec4(0.0);
			float disp = intensity/100.0*(0.5-distance(0.5, progress));
			for (int xi=0; xi<passes; xi++)
			{
				float x = float(xi) / float(passes) - 0.5;
				for (int yi=0; yi<passes; yi++)
				{
					float y = float(yi) / float(passes) - 0.5;
					vec2 v = vec2(x,y);
					float d = disp;
					t1 += texture2D(texture1,newUV1 + d*v);
					t2 += texture2D(texture2,newUV2 + d*v);
				}
			}

			t1 /= float(passes*passes);
			t2 /= float(passes*passes);

			// Use black background color
			// Top right
			vec2 tr1 = step(newUV1, vec2(1.0, 1.0));
			vec2 tr2 = step(newUV2, vec2(1.0, 1.0));
			float pct1 = tr1.x * tr1.y;
			float pct2 = tr2.x * tr2.y;
			// Bottom left
			vec2 bl1 = step(vec2(0.0, 0.0), newUV1);
			vec2 bl2 = step(vec2(0.0, 0.0), newUV2);
			pct1 *= bl1.x * bl1.y;
			pct2 *= bl2.x * bl2.y;
			vec4 t1wb = t1 * vec4(pct1,pct1,pct1,1.0);
			vec4 t2wb = t2 * vec4(pct2,pct2,pct2,1.0);
			gl_FragColor = mix(t1wb, t2wb, progress);
		}
	`;
        this.distortionFrag = `
	uniform float progress;
	uniform sampler2D displacementTexture;
	uniform sampler2D texture1;
    uniform sampler2D texture2;
    uniform vec4 resolution1;
    uniform vec4 resolution2;
	uniform float angle1;
	uniform float angle2;
	uniform float intensity;

	varying vec2 vUv;

	mat2 getRotM(float angle) {
	  float s = sin(angle);
	  float c = cos(angle);
	  return mat2(c, -s, s, c);
	}

	void main() {
	  vec2 newUV1 = (vUv - vec2(0.5,0.5))*resolution1.zw + vec2(0.5,0.5);
      vec2 newUV2 = (vUv - vec2(0.5,0.5))*resolution2.zw + vec2(0.5,0.5);
	  vec4 t1 = texture2D(texture1,newUV1);
      vec4 t2 = texture2D(texture2,newUV2);

	  vec4 disp = texture2D(displacementTexture, newUV1);
	  vec2 dispVec = vec2(disp.r, disp.g);

	  vec2 distortedPosition1 = newUV1 + getRotM(angle1) * dispVec * intensity / 100.0 * progress;
	  vec2 distortedPosition2 = newUV2 + getRotM(angle2) * dispVec * intensity / 100.0 * (1.0 - progress);
	  vec4 t1d = texture2D(texture1, distortedPosition1);
	  vec4 t2d = texture2D(texture2, distortedPosition2);

	  // Use black background color
	  // Top right
	  vec2 tr1 = step(newUV1, vec2(1.0, 1.0));
	  vec2 tr2 = step(newUV2, vec2(1.0, 1.0));
	  float pct1 = tr1.x * tr1.y;
	  float pct2 = tr2.x * tr2.y;
	  // Bottom left
	  vec2 bl1 = step(vec2(0.0, 0.0), newUV1);
	  vec2 bl2 = step(vec2(0.0, 0.0), newUV2);
	  pct1 *= bl1.x * bl1.y;
	  pct2 *= bl2.x * bl2.y;
	  vec4 t1wb = t1d * vec4(pct1,pct1,pct1,1.0);
	  vec4 t2wb = t2d * vec4(pct2,pct2,pct2,1.0);
	  gl_FragColor = mix(t1wb, t2wb, progress);
	}
	`;
    }
}

class ImageTransitionComponent {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.imageUrls = new Array();
        this.transitionDuration = 1000;
        this.animationEnabled = true;
        this.startIndex = 0;
        this.showPerformanceMonitor = false;
        this.imageIndexChange = new EventEmitter();
        this.pAutoPlay = false;
        this.pAutoPlayInterval = 5000;
        this.pImageSize = 'cover';
        this.pTransitionType = 'split';
        this.pIntensity = 40.0;
        this.pScaleX = 50.0;
        this.pScaleY = 50.0;
        this.pWidth = 0.5;
        this.pDistortionImageUrl = '';
        this.renderer = new WebGLRenderer({
            antialias: true,
            alpha: true,
        });
        this.scene = new Scene();
        this.textures = new Array();
        this.nextImageIndex = 0;
        this.tranistionOngoing = false;
        this.shaders = new ImageTransitionShaders();
        this.autoPlay$ = new Observable();
        this.autoPlaySubscription = new Subscription();
        this.subscriptions = new Subscription();
        this.basicAssetsLoaded$$ = new Subject();
        this.forwardTextureLoaded$$ = new Subject();
        this.backwardTextureLoaded$$ = new Subject();
        this.showLoadingSpinner$$ = new Subject();
        this.transitToForwardTexture$$ = new Subject();
        this.transitToBackwardTexture$$ = new Subject();
        // When true -> show spinner after a delay
        // When false -> hide spinner immediatelly
        this.showLoadingSpinner$ = this.showLoadingSpinner$$.pipe(switchMap((show) => {
            if (show) {
                return of(show).pipe(delay(300));
            }
            else {
                return of(show);
            }
        }));
        this.subscribeToInitScene();
        this.subscribeTransistionToBackwardTexture();
        this.subscribeTransistionToForwardTexture();
    }
    get displacementImageUrl() {
        return this.pDistortionImageUrl;
    }
    set displacementImageUrl(displacementImageUrl) {
        this.pDistortionImageUrl = displacementImageUrl;
        if (this.material != null) {
            this.setShaderProperties();
        }
    }
    get imageSize() {
        return this.pImageSize;
    }
    set imageSize(imageSize) {
        this.pImageSize = imageSize;
        if (this.mesh != null) {
            this.resize();
        }
    }
    get autoPlay() {
        return this.pAutoPlay;
    }
    set autoPlay(autoplay) {
        this.pAutoPlay = autoplay;
        if (this.mesh != null) {
            if (this.pAutoPlay === true) {
                this.setAutoPlayInterval();
            }
            else {
                this.stopAutoPlayInterval();
            }
        }
    }
    get autoPlayInterval() {
        return this.pAutoPlayInterval;
    }
    set autoPlayInterval(autoPlayInterval) {
        this.pAutoPlayInterval = autoPlayInterval;
        if (this.mesh != null) {
            if (this.pAutoPlay === true) {
                this.setAutoPlayInterval();
            }
        }
    }
    get transitionType() {
        return this.pTransitionType;
    }
    set transitionType(transitionType) {
        this.pTransitionType = transitionType;
        if (this.material != null) {
            this.setShaderProperties();
        }
    }
    get sizeX() {
        return this.pScaleX;
    }
    set sizeX(sizeX) {
        this.pScaleX = sizeX;
        if (this.material != null) {
            this.setShaderProperties();
        }
    }
    get sizeY() {
        return this.pScaleY;
    }
    set sizeY(sizeY) {
        this.pScaleY = sizeY;
        if (this.material != null) {
            this.setShaderProperties();
        }
    }
    get width() {
        return this.pWidth;
    }
    set width(width) {
        this.pWidth = width;
        if (this.material != null) {
            this.setShaderProperties();
        }
    }
    get intensity() {
        return this.intensity;
    }
    set intensity(intensity) {
        this.pIntensity = intensity;
        if (this.material != null) {
            this.setShaderProperties();
        }
    }
    ngAfterViewInit() {
        if (this.imageUrls.length < 2) {
            throw new Error('At least two images are required');
        }
        // Init camera
        this.camera = new PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.001, 1000);
        this.camera.position.set(0, 0, 2);
        // Init renderer
        this.renderer.setSize(this.threejsContainer.nativeElement.clientWidth, this.threejsContainer.nativeElement.clientHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.threejsContainer.nativeElement.appendChild(this.renderer.domElement);
        // Create scene
        this.scene = new Scene();
        // Load currenct, backwards and forwards textures
        this.textures = new Array(this.imageUrls.length);
        this.loadBasicAssets();
        const backwardImgIdx = this.startIndex === 0 ? this.imageUrls.length - 1 : this.startIndex - 1;
        this.loadTexture(backwardImgIdx, Direction.backward);
        const forwardImgIdx = this.startIndex === this.imageUrls.length - 1 ? 0 : this.startIndex + 1;
        this.loadTexture(forwardImgIdx, Direction.forward);
        // Init autoPlay Observable
        if (this.pAutoPlay === true) {
            this.setAutoPlayInterval();
        }
        this.animate();
    }
    ngOnDestroy() {
        // Cancel Animation
        cancelAnimationFrame(this.animationFrameId);
        // Stop autoplay animation
        this.stopAutoPlayInterval();
        // Remove threejs container from DOM
        this.threejsContainer.nativeElement.removeChild(this.renderer.domElement);
        // Dispose textures
        this.textures.forEach((t) => {
            t.dispose();
        });
        // Dispose material
        if (this.material) {
            this.material.dispose();
        }
        // Clear scene
        if (this.scene) {
            this.scene.clear();
        }
        // Dispose renderer
        if (this.renderer) {
            this.renderer.dispose();
        }
        this.subscriptions.unsubscribe();
    }
    subscribeToInitScene() {
        this.subscriptions.add(this.basicAssetsLoaded$$
            .pipe(tap(() => this.initBasiscScene()))
            .subscribe());
    }
    subscribeTransistionToForwardTexture() {
        this.subscriptions.add(zip(this.transitToForwardTexture$$, this.forwardTextureLoaded$$)
            .pipe(tap(() => this.showLoadingSpinner$$.next(false)), tap(() => this.prepAndLoadNextImg(Direction.forward)))
            .subscribe());
    }
    subscribeTransistionToBackwardTexture() {
        this.subscriptions.add(zip(this.transitToBackwardTexture$$, this.backwardTextureLoaded$$)
            .pipe(tap(() => this.showLoadingSpinner$$.next(false)), tap(() => this.prepAndLoadNextImg(Direction.backward)))
            .subscribe());
    }
    loadBasicAssets() {
        this.showLoadingSpinner$$.next(true);
        const promises = new Array();
        // Initial image to be shown
        promises.push(new Promise((resolve) => {
            this.textures[this.startIndex] = new TextureLoader().load(this.imageUrls[this.startIndex], resolve);
        }));
        if (this.displacementImageUrl !== '') {
            promises.push(new Promise((resolve) => {
                this.displacementTexture = new TextureLoader().load(this.displacementImageUrl, resolve);
            }));
        }
        Promise.all(promises)
            .then(() => this.basicAssetsLoaded$$.next())
            .catch((err) => console.error(err))
            .finally(() => this.showLoadingSpinner$$.next(false));
    }
    loadTexture(index, direction) {
        new TextureLoader()
            .loadAsync(this.imageUrls[index])
            .then((texture) => {
            this.textures[index] = texture;
            switch (direction) {
                case Direction.forward:
                    this.forwardTextureLoaded$$.next();
                    break;
                case Direction.backward:
                    this.backwardTextureLoaded$$.next();
                    break;
            }
        })
            .catch((err) => console.error(err));
    }
    initBasiscScene() {
        // Create geometry
        const geometry = new PlaneBufferGeometry(1, 1, 2, 2);
        this.nextImageIndex = this.startIndex;
        // Emit event to set current image index
        this.imageIndexChange.emit(this.nextImageIndex);
        this.material = new ShaderMaterial({
            side: DoubleSide,
            uniforms: {
                time: { value: 0 },
                progress: { value: 0 },
                border: { value: 0 },
                intensity: { value: 50.0 },
                angle1: { value: Math.PI / 4 },
                angle2: { value: -Math.PI + Math.PI / 4 },
                scaleX: { value: 40.0 },
                scaleY: { value: 40.0 },
                transition: { value: 40.0 },
                swipe: { value: 0 },
                width: { value: 0.5 },
                radius: { value: 0 },
                texture1: { value: this.textures[this.startIndex] },
                texture2: { value: null },
                displacementTexture: { value: this.displacementTexture },
                resolution1: { value: new Vector4() },
                resolution2: { value: new Vector4() },
            },
            // wireframe: true,
            vertexShader: this.shaders.vertex,
        });
        this.setShaderProperties();
        this.mesh = new Mesh(geometry, this.material);
        this.scene.add(this.mesh);
        // Call the resize method once to set the texture resultion correclty
        this.resize();
    }
    /**
     * Sets the autoPlay interval
     */
    setAutoPlayInterval() {
        this.autoPlay$ = interval(this.pAutoPlayInterval);
        this.autoPlaySubscription = this.autoPlay$.pipe(tap(() => this.transitToForwardTexture$$.next())).subscribe();
    }
    /**
     * Resets the autoPlay interval
     */
    resetAutoPlayInterval() {
        this.autoPlay$ = NEVER;
        this.autoPlaySubscription.unsubscribe();
        this.setAutoPlayInterval();
    }
    /**
     * Stops the autoPlay interval
     */
    stopAutoPlayInterval() {
        this.autoPlay$ = NEVER;
        this.autoPlaySubscription.unsubscribe();
    }
    /**
     * Sets the shader properties depending on the transition type
     */
    setShaderProperties() {
        switch (this.transitionType) {
            case 'split':
                this.material.uniforms.intensity.value = this.pIntensity;
                this.material.fragmentShader = this.shaders.splitTransitionFrag;
                break;
            case 'fade':
                this.material.fragmentShader = this.shaders.fadeFrag;
                break;
            case 'noise':
                this.material.uniforms.scaleX.value = this.pScaleX;
                this.material.uniforms.scaleY.value = this.pScaleY;
                this.material.uniforms.width.value = this.pWidth;
                this.material.fragmentShader = this.shaders.noiseFrag;
                break;
            case 'blur':
                this.material.uniforms.intensity.value = this.pIntensity;
                this.material.fragmentShader = this.shaders.blurFrag;
                break;
            case 'distortion':
                this.material.uniforms.displacementTexture.value =
                    new TextureLoader().load(this.displacementImageUrl);
                this.material.uniforms.intensity.value = this.pIntensity;
                this.material.fragmentShader = this.shaders.distortionFrag;
                break;
            default:
                break;
        }
        this.material.needsUpdate = true;
    }
    /**
     * Animation
     */
    animate() {
        if (this.animationEnabled === true) {
            this.renderer.render(this.scene, this.camera);
        }
        if (this.performanceMonitor && this.showPerformanceMonitor) {
            this.performanceMonitor.end();
        }
        this.ngZone.runOutsideAngular(() => {
            this.animationFrameId = window.requestAnimationFrame(() => this.animate());
        });
    }
    /**
     * Resizes the canvas and updates the texture resulution information of the images
     */
    resize() {
        // Get the with and height of the container
        const containerWidth = this.threejsContainer.nativeElement.offsetWidth;
        const containerHeight = this.threejsContainer.nativeElement.offsetHeight;
        // return the function, if eihter with or heigth is undefined
        if (!containerHeight || !containerHeight) {
            return;
        }
        this.renderer.setSize(containerWidth, containerHeight);
        this.camera.aspect = containerWidth / containerHeight;
        this.updateTextureResolution(this.nextImageIndex, 1);
        const dist = this.camera.position.z;
        const height = 1;
        this.camera.fov = 2 * (180 / Math.PI) * Math.atan(height / (2 * dist));
        this.mesh.scale.x = this.camera.aspect;
        this.mesh.scale.y = 1;
        this.camera.updateProjectionMatrix();
    }
    /**
     * Updates the resulution of the texture for the shader depending on the image size type
     * @param textureNumber Number of the texture
     */
    updateTextureResolution(textureNumber, targetGlslTexture) {
        const texture = this.textures[textureNumber];
        const containerWidth = this.threejsContainer.nativeElement.offsetWidth;
        const containerHeight = this.threejsContainer.nativeElement.offsetHeight;
        // Adapt the size of the image
        const imageAspect = texture.image.height / texture.image.width;
        const containerAspect = containerHeight / containerWidth;
        let a1;
        let a2;
        if (this.pImageSize === 'cover') {
            if (containerAspect > imageAspect) {
                a1 = (containerWidth / containerHeight) * imageAspect;
                a2 = 1;
            }
            else {
                a1 = 1;
                a2 = containerHeight / containerWidth / imageAspect;
            }
        }
        else if (this.pImageSize === 'contain') {
            if (containerAspect < imageAspect) {
                a1 = (containerWidth / containerHeight) * imageAspect;
                a2 = 1;
            }
            else {
                a1 = 1;
                a2 = containerHeight / containerWidth / imageAspect;
            }
        }
        if (targetGlslTexture === 1) {
            this.material.uniforms.resolution1.value.x = containerWidth;
            this.material.uniforms.resolution1.value.y = containerHeight;
            this.material.uniforms.resolution1.value.z = a1;
            this.material.uniforms.resolution1.value.w = a2;
        }
        else if (targetGlslTexture === 2) {
            this.material.uniforms.resolution2.value.x = containerWidth;
            this.material.uniforms.resolution2.value.y = containerHeight;
            this.material.uniforms.resolution2.value.z = a1;
            this.material.uniforms.resolution2.value.w = a2;
        }
    }
    /**
     * Starts the transition effect to the next image
     * @param posDirection indicator, if the next or previous image should be loaded
     */
    transitionToNextTexture(direction) {
        // EventEmitter
        this.imageIndexChange.emit(this.nextImageIndex);
        this.ngZone.runOutsideAngular(() => {
            if (direction === Direction.backward) {
                this.material.uniforms.texture2.value =
                    this.material.uniforms.texture1.value;
                this.material.uniforms.resolution2.value.x =
                    this.material.uniforms.resolution1.value.x;
                this.material.uniforms.resolution2.value.y =
                    this.material.uniforms.resolution1.value.y;
                this.material.uniforms.resolution2.value.z =
                    this.material.uniforms.resolution1.value.z;
                this.material.uniforms.resolution2.value.w =
                    this.material.uniforms.resolution1.value.w;
                this.material.uniforms.progress.value = 1;
                // Set the next image to texture1 and update the resolution
                this.material.uniforms.texture1.value =
                    this.textures[this.nextImageIndex];
                this.updateTextureResolution(this.nextImageIndex, 1);
                // Start the tween for doing the transition
                RxjsTween.createTween(RxjsTween.linear, 1, 0, this.transitionDuration).subscribe({
                    next: (val) => {
                        this.material.uniforms.progress.value = val;
                    },
                    complete: () => {
                        // Set the transition flag to false to indicate that the transition animation is finished
                        this.tranistionOngoing = false;
                        // Reset progress to 1, thus the texture from texture 2 needs to be set to texture 1
                        this.material.uniforms.texture2.value =
                            this.textures[this.nextImageIndex];
                        this.updateTextureResolution(this.nextImageIndex, 2);
                        this.material.uniforms.progress.value = 0;
                    },
                });
            }
            else {
                // Set the next image to texture2 and update the resolution
                this.material.uniforms.texture2.value =
                    this.textures[this.nextImageIndex];
                this.updateTextureResolution(this.nextImageIndex, 2);
                // Start the tween for doing the transition
                RxjsTween.createTween(RxjsTween.linear, 0, 1, this.transitionDuration).subscribe({
                    next: (val) => {
                        this.material.uniforms.progress.value = val;
                    },
                    complete: () => {
                        // Set the transition flag to false to indicate that the transition animation is finished
                        this.tranistionOngoing = false;
                        // Reset progress to 0, thus the texture from texture 2 needs to be set to texture 1
                        this.material.uniforms.texture1.value =
                            this.textures[this.nextImageIndex];
                        this.updateTextureResolution(this.nextImageIndex, 1);
                        this.material.uniforms.progress.value = 0;
                    },
                });
            }
        });
    }
    prepAndLoadNextImg(direction) {
        // Set the flag to indicate that the transition animation is ongoing
        this.tranistionOngoing = true;
        let nextButOne = 0;
        if (direction === Direction.forward) {
            // Set the next index
            this.nextImageIndex =
                this.nextImageIndex < this.imageUrls.length - 1
                    ? this.nextImageIndex + 1
                    : 0;
            // Check if another texture needs to be loaded
            nextButOne =
                this.nextImageIndex + 1 > this.imageUrls.length - 1
                    ? 0
                    : this.nextImageIndex + 1;
            this.loadTexture(nextButOne, Direction.forward);
        }
        else {
            // Update the number of the current shown image
            this.nextImageIndex =
                this.nextImageIndex > 0
                    ? this.nextImageIndex - 1
                    : this.imageUrls.length - 1;
            // Check if another texture needs to be loaded
            nextButOne =
                this.nextImageIndex - 1 < 0
                    ? this.imageUrls.length - 1
                    : this.nextImageIndex - 1;
            this.loadTexture(nextButOne, Direction.backward);
        }
        this.transitionToNextTexture(direction);
    }
    nextImage(direction) {
        if (this.tranistionOngoing) {
            console.warn('cannot go to next image. transition still ongoing.');
            return;
        }
        if (this.pAutoPlay) {
            this.resetAutoPlayInterval();
        }
        this.showLoadingSpinner$$.next(true);
        switch (direction) {
            case Direction.backward:
                this.transitToBackwardTexture$$.next();
                break;
            case Direction.forward:
                this.transitToForwardTexture$$.next();
                break;
        }
    }
    //#region public methods
    next() {
        this.nextImage(Direction.forward);
    }
    prev() {
        this.nextImage(Direction.backward);
    }
}
ImageTransitionComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: ImageTransitionComponent, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
ImageTransitionComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.1", type: ImageTransitionComponent, selector: "lib-image-transition", inputs: { imageUrls: "imageUrls", displacementImageUrl: "displacementImageUrl", imageSize: "imageSize", autoPlay: "autoPlay", autoPlayInterval: "autoPlayInterval", transitionDuration: "transitionDuration", transitionType: "transitionType", sizeX: "sizeX", sizeY: "sizeY", width: "width", intensity: "intensity", animationEnabled: "animationEnabled", startIndex: "startIndex", showPerformanceMonitor: "showPerformanceMonitor" }, outputs: { imageIndexChange: "imageIndexChange" }, host: { listeners: { "window:resize": "resize()" } }, viewQueries: [{ propertyName: "threejsContainer", first: true, predicate: ["threejsContainer"], descendants: true }, { propertyName: "performanceMonitor", first: true, predicate: ["performanceMonitor"], descendants: true }], ngImport: i0, template: "<div #threejsContainer class=\"threejs-container\">\r\n  <div *ngIf=\"showLoadingSpinner$ | async\" class=\"loading-container\">\r\n    <div class=\"lds-ripple\">\r\n      <div></div>\r\n      <div></div>\r\n    </div>\r\n  </div>\r\n</div>\r\n<acuw-performance-monitor\r\n  *ngIf=\"showPerformanceMonitor\"\r\n  #performanceMonitor\r\n></acuw-performance-monitor>\r\n", styles: [".threejs-container{position:relative;width:100%;height:100%}.loading-container{position:absolute;width:100%;height:100%;display:flex;justify-content:center;align-items:center}.lds-ripple{display:inline-block;position:relative;width:80px;height:80px;background-color:#0006;border-radius:40px;box-shadow:0 0 24px 12px #00000080}.lds-ripple div{position:absolute;border:4px solid #fff;opacity:1;border-radius:50%;animation:lds-ripple 1s cubic-bezier(0,.2,.8,1) infinite}.lds-ripple div:nth-child(2){animation-delay:-.5s}@keyframes lds-ripple{0%{top:36px;left:36px;width:0;height:0;opacity:1}to{top:0px;left:0px;width:72px;height:72px;opacity:0}}\n"], components: [{ type: PerformanceMonitorComponent, selector: "acuw-performance-monitor" }], directives: [{ type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i2.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: ImageTransitionComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lib-image-transition', template: "<div #threejsContainer class=\"threejs-container\">\r\n  <div *ngIf=\"showLoadingSpinner$ | async\" class=\"loading-container\">\r\n    <div class=\"lds-ripple\">\r\n      <div></div>\r\n      <div></div>\r\n    </div>\r\n  </div>\r\n</div>\r\n<acuw-performance-monitor\r\n  *ngIf=\"showPerformanceMonitor\"\r\n  #performanceMonitor\r\n></acuw-performance-monitor>\r\n", styles: [".threejs-container{position:relative;width:100%;height:100%}.loading-container{position:absolute;width:100%;height:100%;display:flex;justify-content:center;align-items:center}.lds-ripple{display:inline-block;position:relative;width:80px;height:80px;background-color:#0006;border-radius:40px;box-shadow:0 0 24px 12px #00000080}.lds-ripple div{position:absolute;border:4px solid #fff;opacity:1;border-radius:50%;animation:lds-ripple 1s cubic-bezier(0,.2,.8,1) infinite}.lds-ripple div:nth-child(2){animation-delay:-.5s}@keyframes lds-ripple{0%{top:36px;left:36px;width:0;height:0;opacity:1}to{top:0px;left:0px;width:72px;height:72px;opacity:0}}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }]; }, propDecorators: { imageUrls: [{
                type: Input
            }], displacementImageUrl: [{
                type: Input
            }], imageSize: [{
                type: Input
            }], autoPlay: [{
                type: Input
            }], autoPlayInterval: [{
                type: Input
            }], transitionDuration: [{
                type: Input
            }], transitionType: [{
                type: Input
            }], sizeX: [{
                type: Input
            }], sizeY: [{
                type: Input
            }], width: [{
                type: Input
            }], intensity: [{
                type: Input
            }], animationEnabled: [{
                type: Input
            }], startIndex: [{
                type: Input
            }], showPerformanceMonitor: [{
                type: Input
            }], imageIndexChange: [{
                type: Output
            }], threejsContainer: [{
                type: ViewChild,
                args: ['threejsContainer']
            }], performanceMonitor: [{
                type: ViewChild,
                args: ['performanceMonitor']
            }], resize: [{
                type: HostListener,
                args: ['window:resize']
            }] } });

class ImageTransitionModule {
}
ImageTransitionModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: ImageTransitionModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ImageTransitionModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: ImageTransitionModule, declarations: [ImageTransitionComponent], imports: [CommonModule, PerformanceMonitorModule], exports: [ImageTransitionComponent] });
ImageTransitionModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: ImageTransitionModule, imports: [[
            CommonModule, PerformanceMonitorModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: ImageTransitionModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [ImageTransitionComponent],
                    imports: [
                        CommonModule, PerformanceMonitorModule
                    ],
                    exports: [ImageTransitionComponent]
                }]
        }] });

class LightboxOverlayComponent {
    constructor(changeRef) {
        this.changeRef = changeRef;
        this.imageUrls = new Array();
        this.displacementImageUrl = '';
        this.forceFullscreen = false;
        this.forceShowNavButtons = false;
        this.imageSize = 'cover';
        this.autoPlay = false;
        this.autoPlayInterval = 5000;
        this.transitionDuration = 1000;
        this.transitionType = 'split';
        this.sizeX = 50.0;
        this.sizeY = 50.0;
        this.width = 0.5;
        this.intensity = 40.0;
        this.startIndex = 0;
        this.currentImageIndex = 1;
        this.showPerformanceMonitor = false;
        this.swipeCoord = new Array();
        this.swipeTime = 0;
    }
    ngOnInit() {
    }
    keyEvent(event) {
        if (event.key === 'ArrowRight') {
            this.imageTransition.next();
        }
        if (event.key === 'ArrowLeft') {
            this.imageTransition.prev();
        }
        if (event.key === 'Escape') {
            this.close();
        }
    }
    /**
     * Close the lightbox
     */
    close() {
        this.overlayRef?.detach();
    }
    /**
     * method to set the index counter
     * @param index index of the image
     */
    imageIndexChange(index) {
        this.currentImageIndex = index + 1;
        this.changeRef.detectChanges();
    }
    /**
     * Listen to touche events for gestures (mobile)
     * @param e touch event
     * @param when indicator if 'start' or 'end'
     */
    swipe(e, when) {
        const coord = [e.changedTouches[0].clientX, e.changedTouches[0].clientY];
        const time = new Date().getTime();
        if (when === 'start') {
            this.swipeCoord = coord;
            this.swipeTime = time;
        }
        else if (when === 'end') {
            const direction = [coord[0] - this.swipeCoord[0], coord[1] - this.swipeCoord[1]];
            const duration = time - this.swipeTime;
            if (duration < 1000 && Math.abs(direction[0]) > 30 // Long enough
                && Math.abs(direction[0]) > Math.abs(direction[1] * 3)) { // Horizontal enough
                const swipe = direction[0] < 0 ? 'next' : 'previous';
                if (swipe === 'next') {
                    this.imageTransition.next();
                }
                else if (swipe === 'previous') {
                    this.imageTransition.prev();
                }
            }
        }
    }
}
LightboxOverlayComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: LightboxOverlayComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
LightboxOverlayComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.1", type: LightboxOverlayComponent, selector: "lib-lightbox-overlay", host: { listeners: { "window:keyup": "keyEvent($event)" } }, viewQueries: [{ propertyName: "imageTransition", first: true, predicate: ImageTransitionComponent, descendants: true }], ngImport: i0, template: "<div [ngClass]=\"{'full-container': forceFullscreen === true, 'auto-container': forceFullscreen === false }\">\r\n    <div class=\"index-indicator\">\r\n        <span>{{ currentImageIndex }}</span>\r\n        <span>/</span>\r\n        <span>{{ imageUrls.length }}</span>\r\n    </div>\r\n    <svg class=\"ligthbox-button close-button\" (click)=\"close()\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"white\">\r\n        <path d=\"M0 0h24v24H0z\" fill=\"none\" />\r\n        <path d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\" />\r\n    </svg>\r\n\r\n    <svg [ngClass]=\"{'auto-visibility': forceShowNavButtons === false}\" \r\n        class=\"ligthbox-button prev-button\" (click)=\"imageTransition.prev()\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"white\">\r\n        <path d=\"M0 0h24v24H0z\" fill=\"none\" />\r\n        <path d=\"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\" />\r\n    </svg>\r\n\r\n    <svg [ngClass]=\"{'auto-visibility': forceShowNavButtons === false}\" \r\n        class=\"ligthbox-button next-button\" (click)=\"imageTransition.next()\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"white\">\r\n        <path d=\"M0 0h24v24H0z\" fill=\"none\" />\r\n        <path d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\" />\r\n    </svg>\r\n    <lib-image-transition #imageTransition [imageUrls]=\"imageUrls\" [startIndex]=\"startIndex\" (imageIndexChange)=\"imageIndexChange($event)\"\r\n        [imageSize]=\"imageSize\" [autoPlay]=\"autoPlay\" [autoPlayInterval]=\"autoPlayInterval\" [transitionDuration]=\"transitionDuration\"\r\n        [transitionType]=\"transitionType\" [sizeX]=\"sizeX\" [sizeY]=\"sizeY\" [width]=\"width\" [intensity]=\"intensity\"\r\n        (touchstart)=\"swipe($event, 'start')\" (touchend)=\"swipe($event, 'end')\"\r\n        [displacementImageUrl]=\"displacementImageUrl\" [showPerformanceMonitor]=\"showPerformanceMonitor\">\r\n    </lib-image-transition>\r\n</div>", styles: [".auto-container{position:relative;width:1100px;height:800px;max-width:90vw;max-height:90vh;background-color:#000;box-shadow:0 0 15px 10px #00000080}.full-container{position:relative;width:100vw;height:100vh;max-width:100vw;max-height:100vh;background-color:#000;box-shadow:0 0 15px 10px #00000080}.index-indicator{position:absolute;z-index:1;color:#fff;background-color:#0006;border-radius:0 0 5px;padding:8px}.ligthbox-button{position:absolute;z-index:1;cursor:pointer;background-color:#0006;width:36px;height:36px}.ligthbox-button:hover{fill:#ffffff80}.close-button{top:0;right:0;border-radius:0 0 0 5px}.prev-button{top:calc(50% - 18px);left:0;border-radius:0 5px 5px 0}.next-button{top:calc(50% - 18px);right:0;border-radius:5px 0 0 5px}@media (max-width: 600px){.auto-container{width:100vw;height:100vh;max-width:100vw;max-height:100vh}.auto-visibility{visibility:collapse}}lib-image-transition{touch-action:none}\n"], components: [{ type: ImageTransitionComponent, selector: "lib-image-transition", inputs: ["imageUrls", "displacementImageUrl", "imageSize", "autoPlay", "autoPlayInterval", "transitionDuration", "transitionType", "sizeX", "sizeY", "width", "intensity", "animationEnabled", "startIndex", "showPerformanceMonitor"], outputs: ["imageIndexChange"] }], directives: [{ type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: LightboxOverlayComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lib-lightbox-overlay', template: "<div [ngClass]=\"{'full-container': forceFullscreen === true, 'auto-container': forceFullscreen === false }\">\r\n    <div class=\"index-indicator\">\r\n        <span>{{ currentImageIndex }}</span>\r\n        <span>/</span>\r\n        <span>{{ imageUrls.length }}</span>\r\n    </div>\r\n    <svg class=\"ligthbox-button close-button\" (click)=\"close()\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"white\">\r\n        <path d=\"M0 0h24v24H0z\" fill=\"none\" />\r\n        <path d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\" />\r\n    </svg>\r\n\r\n    <svg [ngClass]=\"{'auto-visibility': forceShowNavButtons === false}\" \r\n        class=\"ligthbox-button prev-button\" (click)=\"imageTransition.prev()\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"white\">\r\n        <path d=\"M0 0h24v24H0z\" fill=\"none\" />\r\n        <path d=\"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\" />\r\n    </svg>\r\n\r\n    <svg [ngClass]=\"{'auto-visibility': forceShowNavButtons === false}\" \r\n        class=\"ligthbox-button next-button\" (click)=\"imageTransition.next()\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"white\">\r\n        <path d=\"M0 0h24v24H0z\" fill=\"none\" />\r\n        <path d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\" />\r\n    </svg>\r\n    <lib-image-transition #imageTransition [imageUrls]=\"imageUrls\" [startIndex]=\"startIndex\" (imageIndexChange)=\"imageIndexChange($event)\"\r\n        [imageSize]=\"imageSize\" [autoPlay]=\"autoPlay\" [autoPlayInterval]=\"autoPlayInterval\" [transitionDuration]=\"transitionDuration\"\r\n        [transitionType]=\"transitionType\" [sizeX]=\"sizeX\" [sizeY]=\"sizeY\" [width]=\"width\" [intensity]=\"intensity\"\r\n        (touchstart)=\"swipe($event, 'start')\" (touchend)=\"swipe($event, 'end')\"\r\n        [displacementImageUrl]=\"displacementImageUrl\" [showPerformanceMonitor]=\"showPerformanceMonitor\">\r\n    </lib-image-transition>\r\n</div>", styles: [".auto-container{position:relative;width:1100px;height:800px;max-width:90vw;max-height:90vh;background-color:#000;box-shadow:0 0 15px 10px #00000080}.full-container{position:relative;width:100vw;height:100vh;max-width:100vw;max-height:100vh;background-color:#000;box-shadow:0 0 15px 10px #00000080}.index-indicator{position:absolute;z-index:1;color:#fff;background-color:#0006;border-radius:0 0 5px;padding:8px}.ligthbox-button{position:absolute;z-index:1;cursor:pointer;background-color:#0006;width:36px;height:36px}.ligthbox-button:hover{fill:#ffffff80}.close-button{top:0;right:0;border-radius:0 0 0 5px}.prev-button{top:calc(50% - 18px);left:0;border-radius:0 5px 5px 0}.next-button{top:calc(50% - 18px);right:0;border-radius:5px 0 0 5px}@media (max-width: 600px){.auto-container{width:100vw;height:100vh;max-width:100vw;max-height:100vh}.auto-visibility{visibility:collapse}}lib-image-transition{touch-action:none}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { imageTransition: [{
                type: ViewChild,
                args: [ImageTransitionComponent]
            }], keyEvent: [{
                type: HostListener,
                args: ['window:keyup', ['$event']]
            }] } });

class LightboxComponent {
    constructor(overlay) {
        this.overlay = overlay;
        this.imageUrls = new Array();
        this.displacementImageUrl = '';
        this.forceFullscreen = false;
        this.forceShowNavButtons = false;
        this.imageSize = 'cover';
        this.autoPlay = false;
        this.autoPlayInterval = 5000;
        this.transitionDuration = 1000;
        this.transitionType = 'split';
        this.sizeX = 50.0;
        this.sizeY = 50.0;
        this.width = 0.5;
        this.intensity = 40.0;
        this.showPerformanceMonitor = false;
    }
    ngOnInit() {
    }
    open(index = 0) {
        // Define settings of the overlay
        this.overlayRef = this.overlay.create({
            hasBackdrop: true,
            positionStrategy: this.overlay.position().global().centerHorizontally().centerVertically(),
            scrollStrategy: this.overlay.scrollStrategies.block()
        });
        // Listen to backdrop event for detaching the overlay
        this.overlayRef.backdropClick().subscribe({
            next: () => { this.overlayRef?.detach(); }
        });
        // Attach the LightboxOverlayComponent to the overlayRef instance
        const lightboxOverlayRef = this.overlayRef.attach(new ComponentPortal(LightboxOverlayComponent));
        // Pass data to the LightboxOverlayComponent
        lightboxOverlayRef.instance.overlayRef = this.overlayRef;
        lightboxOverlayRef.instance.imageUrls = this.imageUrls;
        lightboxOverlayRef.instance.displacementImageUrl = this.displacementImageUrl;
        lightboxOverlayRef.instance.forceFullscreen = this.forceFullscreen;
        lightboxOverlayRef.instance.forceShowNavButtons = this.forceShowNavButtons;
        lightboxOverlayRef.instance.imageSize = this.imageSize;
        lightboxOverlayRef.instance.autoPlay = this.autoPlay;
        lightboxOverlayRef.instance.autoPlayInterval = this.autoPlayInterval;
        lightboxOverlayRef.instance.transitionDuration = this.transitionDuration;
        lightboxOverlayRef.instance.transitionType = this.transitionType;
        lightboxOverlayRef.instance.sizeX = this.sizeX;
        lightboxOverlayRef.instance.sizeY = this.sizeY;
        lightboxOverlayRef.instance.width = this.width;
        lightboxOverlayRef.instance.intensity = this.intensity;
        lightboxOverlayRef.instance.startIndex = index;
        lightboxOverlayRef.instance.showPerformanceMonitor = this.showPerformanceMonitor;
    }
    close() {
        this.overlayRef?.detach();
    }
}
LightboxComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: LightboxComponent, deps: [{ token: i1.Overlay }], target: i0.ɵɵFactoryTarget.Component });
LightboxComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.1", type: LightboxComponent, selector: "lib-lightbox", inputs: { imageUrls: "imageUrls", displacementImageUrl: "displacementImageUrl", forceFullscreen: "forceFullscreen", forceShowNavButtons: "forceShowNavButtons", imageSize: "imageSize", autoPlay: "autoPlay", autoPlayInterval: "autoPlayInterval", transitionDuration: "transitionDuration", transitionType: "transitionType", sizeX: "sizeX", sizeY: "sizeY", width: "width", intensity: "intensity", showPerformanceMonitor: "showPerformanceMonitor" }, ngImport: i0, template: '', isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: LightboxComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'lib-lightbox',
                    template: ''
                }]
        }], ctorParameters: function () { return [{ type: i1.Overlay }]; }, propDecorators: { imageUrls: [{
                type: Input
            }], displacementImageUrl: [{
                type: Input
            }], forceFullscreen: [{
                type: Input
            }], forceShowNavButtons: [{
                type: Input
            }], imageSize: [{
                type: Input
            }], autoPlay: [{
                type: Input
            }], autoPlayInterval: [{
                type: Input
            }], transitionDuration: [{
                type: Input
            }], transitionType: [{
                type: Input
            }], sizeX: [{
                type: Input
            }], sizeY: [{
                type: Input
            }], width: [{
                type: Input
            }], intensity: [{
                type: Input
            }], showPerformanceMonitor: [{
                type: Input
            }] } });

class LightboxModule {
}
LightboxModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: LightboxModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
LightboxModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: LightboxModule, declarations: [LightboxComponent, LightboxOverlayComponent], imports: [CommonModule,
        ImageTransitionModule,
        OverlayModule,
        PerformanceMonitorModule], exports: [LightboxComponent] });
LightboxModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: LightboxModule, imports: [[
            CommonModule,
            ImageTransitionModule,
            OverlayModule,
            PerformanceMonitorModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: LightboxModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [LightboxComponent, LightboxOverlayComponent],
                    imports: [
                        CommonModule,
                        ImageTransitionModule,
                        OverlayModule,
                        PerformanceMonitorModule
                    ],
                    exports: [LightboxComponent]
                }]
        }] });

class ObjectControls {
    constructor(rendererDom, object, touchArea) {
        // ============= Private Properties =============
        this.isUserInteracting = false;
        this.restoringAnimationOngoing = false;
        this.restoringOriginPosTimeout = 0;
        this.userInteracted = false;
        this.userInteractedSubject = new Subject();
        // ============= Public Properties =============
        this.rotationSpeed = 1;
        this.verticalRotation = true;
        this.horizontalRotation = true;
        this.autoRotationY = false;
        this.autoRotationX = false;
        this.autoRotationZ = false;
        this.restoreOriginPosition = false;
        this.autoRotationSpeed = 0.002;
        this.userInteracted$ = this.userInteractedSubject.asObservable();
        this.controlsEnabled = true;
        /******************  MOUSE interaction functions - desktop  *****/
        /**
         * Prepares everything, when the mouse is clicked
         * @param e mouse event
         */
        this.mouseDown = (e) => {
            // Ignore mouse down interaction, if the controls are not enabled
            // Ignore mouse down interaction, if the restoration animation is ongoing
            if (this.controlsEnabled === false || this.restoringAnimationOngoing === true)
                return;
            // Reset restoration animation timout
            window.clearTimeout(this.restoringOriginPosTimeout);
            this.isUserInteracting = true;
            this.startDraggingPosition = new Vector2(0, 0);
            this.startDraggingPosition.set(e.offsetX, e.offsetY);
            this.touchArea.addEventListener('pointermove', this.mouseMove, false);
            this.touchArea.addEventListener('pointerup', this.mouseUp, false);
        };
        /**
         * Calculates the x and y rotation of the object depending on the mouse movement
         * @param e MouseEvent
         */
        this.mouseMove = (e) => {
            // Ignore mouse movement interaction, if the controls are not enabled
            // Ignore mouse movement interaction, if the restoration animation is ongoing
            if (this.controlsEnabled === false || this.restoringAnimationOngoing)
                return;
            if (this.isUserInteracting) {
                if (this.userInteracted == false) {
                    this.userInteracted = true;
                    this.userInteractedSubject.next(this.userInteracted);
                }
                const deltaMove = new Vector2(e.offsetX - this.startDraggingPosition.x, e.offsetY - this.startDraggingPosition.y);
                this.startDraggingPosition.set(e.offsetX, e.offsetY);
                const rotationX = this.verticalRotation == true ? (deltaMove.x * Math.PI / 180 * this.rotationSpeed) : 0;
                const rotationY = this.horizontalRotation == true ? (deltaMove.y * Math.PI / 180 * this.rotationSpeed) : 0;
                var deltaRotationQuaternion = new Quaternion().setFromEuler(new Euler(rotationY, rotationX, 0, 'XYZ'));
                this.obj.quaternion.multiplyQuaternions(deltaRotationQuaternion, this.obj.quaternion);
                //console.log(`rotX: ${Math.round(THREE.MathUtils.radToDeg(this.obj.rotation.x))}, rotY: ${Math.round(THREE.MathUtils.radToDeg(this.obj.rotation.y))}, rotZ: ${Math.round(THREE.MathUtils.radToDeg(this.obj.rotation.z))}`);
            }
        };
        this.mouseUp = () => {
            // Ignore mouse movement interaction, if the controls are not enabled
            // Ignore mouse up interaction, if the restoration animation is ongoing
            if (this.controlsEnabled === false || this.restoringAnimationOngoing)
                return;
            this.resetMousePosition();
            this.isUserInteracting = false;
            if (this.restoreOriginPosition)
                this.restoreOriginalPosition();
            this.touchArea.removeEventListener('mousemove', this.mouseMove, false);
            this.touchArea.removeEventListener('mouseup', this.mouseUp, false);
        };
        /****************** TOUCH interaction functions - mobile  *****/
        this.onTouchStart = (e) => {
            // Ignore mouse movement interaction, if the controls are not enabled
            // Ignore touch start interaction, if the restoration animation is ongoing
            if (this.controlsEnabled === false || this.restoringAnimationOngoing)
                return;
            // Reset restoration animation timout
            window.clearTimeout(this.restoringOriginPosTimeout);
            //e.preventDefault();
            this.isUserInteracting = true;
            this.restoringAnimationOngoing = false;
            this.startDraggingPosition.set(e.touches[0].pageX, e.touches[0].pageY);
        };
        this.onTouchMove = (e) => {
            // Ignore mouse movement interaction, if the controls are not enabled
            // Ignore mouse move interaction, if the restoration animation is ongoing
            if (this.controlsEnabled === false || this.restoringAnimationOngoing)
                return;
            //e.preventDefault();
            if (this.isUserInteracting && !this.restoringAnimationOngoing) {
                if (this.userInteracted == false) {
                    this.userInteracted = true;
                    this.userInteractedSubject.next(this.userInteracted);
                }
                const deltaMove = new Vector2(e.touches[0].pageX - this.startDraggingPosition.x, e.touches[0].pageY - this.startDraggingPosition.y);
                this.startDraggingPosition.set(e.touches[0].pageX, e.touches[0].pageY);
                const rotationX = this.verticalRotation == true ? (deltaMove.x * Math.PI / 180 * this.rotationSpeed) : 0;
                const rotationY = this.horizontalRotation == true ? (deltaMove.y * Math.PI / 180 * this.rotationSpeed) : 0;
                var deltaRotationQuaternion = new Quaternion().setFromEuler(new Euler(rotationY, rotationX, 0, 'XYZ'));
                this.obj.quaternion.multiplyQuaternions(deltaRotationQuaternion, this.obj.quaternion);
            }
        };
        this.onTouchEnd = (e) => {
            // Ignore mouse movement interaction, if the controls are not enabled
            // Ignore mouse up interaction, if the restoration animation is ongoing
            if (this.controlsEnabled === false || this.restoringAnimationOngoing)
                return;
            //e.preventDefault();
            this.isUserInteracting = false;
            this.resetMousePosition();
            if (this.restoreOriginPosition)
                this.restoreOriginalPosition();
        };
        this.rendererDom = rendererDom;
        this.obj = object;
        this.touchArea = touchArea != null ? touchArea : this.rendererDom;
        this.startDraggingPosition = new Vector2(0, 0);
        this.addEventlisteners();
    }
    // ============= Public Methods =============
    /**
     * Method, which needs to be called, in case autorotation is used
     */
    update() {
        if (this.isUserInteracting || this.restoringAnimationOngoing || this.userInteracted)
            return;
        var rotationY = this.autoRotationY == true ? this.autoRotationSpeed : 0;
        var rotationX = this.autoRotationX == true ? this.autoRotationSpeed : 0;
        var rorationZ = this.autoRotationZ == true ? this.autoRotationSpeed : 0;
        var deltaRotationQuaternion = new Quaternion().setFromEuler(new Euler(rotationX, rotationY, rorationZ, 'XYZ'));
        this.obj.quaternion.multiplyQuaternions(deltaRotationQuaternion, this.obj.quaternion);
    }
    /**
     * Removes the event listners
     */
    removeEventlisteners() {
        // desktop events
        this.touchArea.removeEventListener('mousedown', this.mouseDown, false);
        this.touchArea.removeEventListener('mousemove', this.mouseMove, false);
        this.touchArea.removeEventListener('mouseup', this.mouseUp, false);
        // mobile events
        this.touchArea.removeEventListener('touchstart', this.onTouchStart, false);
        this.touchArea.removeEventListener('touchmove', this.onTouchMove, false);
        this.touchArea.removeEventListener('touchend', this.onTouchEnd, false);
    }
    resetUserInteractionFlag() {
        this.userInteracted = false,
            this.userInteractedSubject.next(this.userInteracted);
    }
    // ============= Private Methods =============
    /**
     * Adds the event listeners
     */
    addEventlisteners() {
        // desktop events
        this.touchArea.addEventListener('mousedown', this.mouseDown, false);
        // mobile events
        this.touchArea.addEventListener('touchend', this.onTouchEnd, false);
        this.touchArea.addEventListener('touchstart', this.onTouchStart, false);
        this.touchArea.addEventListener('touchmove', this.onTouchMove, false);
    }
    /**
     * Reset the mouse position to x=0 and y=0
     */
    resetMousePosition() {
        this.startDraggingPosition.set(0, 0);
    }
    /**
     * Rotates the object to the position 0,0,0 after a some timeout
     */
    restoreOriginalPosition() {
        this.restoringOriginPosTimeout = window.setTimeout(() => {
            var objSet = new Object3D();
            objSet.position.set(0, 0, 0);
            objSet.rotation.set(0, 0, 0);
            RxjsTween.createTween(RxjsTween.linear, [this.obj.position.x, this.obj.position.y, this.obj.position.z], [objSet.position.x, objSet.position.y, objSet.position.z], 1000).subscribe({
                next: tweenVal => {
                    if (this.restoringAnimationOngoing == false)
                        this.restoringAnimationOngoing = true;
                    this.obj.rotation.set(tweenVal[0], tweenVal[1], tweenVal[2]);
                },
                complete: () => {
                    this.restoringAnimationOngoing = false;
                    this.resetUserInteractionFlag();
                }
            });
        }, 5000);
    }
}

class CarouselItem {
    constructor(el) {
        this.el = el;
        this.htmlElement = this.el.nativeElement;
    }
}
CarouselItem.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: CarouselItem, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
CarouselItem.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.1.1", type: CarouselItem, selector: "acuw-carousel-item", host: { classAttribute: "acuw-carousel-item" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: CarouselItem, decorators: [{
            type: Directive,
            args: [{
                    selector: `acuw-carousel-item`,
                    host: {
                        'class': 'acuw-carousel-item',
                    }
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });
class CarouselComponent {
    constructor(ngZone, animationBuilder) {
        this.ngZone = ngZone;
        this.animationBuilder = animationBuilder;
        this.showDots = true;
        this.dotColor = '#fff';
        this.activeDotColor = '#3f51b5';
        this.dotAnimationCircleColor = '#fff';
        this.activeCarouselElement = 0;
        this.initAnimation = true;
        this.radius = 200;
        this.yPosition = 0;
        this.cameraFov = 65;
        this.cameraDistance = 600;
        this.autoPlay = false;
        this.autoPlayInterval = 5000;
        this.rotationDuration = 500;
        this.showPerformanceMonitor = false;
        this.activeElementChanged = new EventEmitter();
        this.css3dRenderer = new CSS3DRenderer();
        this.scene = new Scene();
        this.carouselGroup = new Group();
        this.carouselObjSubsciptions = new Array();
        this.rotationSubscription = new Subscription();
        this.animation = true;
        this.userMove = false;
    }
    ngAfterViewInit() {
        // Init camera
        this.camera = new PerspectiveCamera(this.cameraFov, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0.0, 0.0, this.cameraDistance);
        // Get the with and heigth of the threejs renderer
        const divWidth = this.threejsContainer.nativeElement.clientWidth;
        const divHeight = this.threejsContainer.nativeElement.clientHeight;
        // Create CSS3D Renderer
        this.css3dRenderer = new CSS3DRenderer();
        this.css3dRenderer.setSize(divWidth, divHeight);
        this.css3dRenderer.domElement.style.position = 'absolute';
        this.css3dRenderer.domElement.style.top = '0';
        this.threejsContainer.nativeElement.appendChild(this.css3dRenderer.domElement);
        // Init carousel elements
        this.initCarouselObjects();
        // Object-Controls
        this.objectControls = new ObjectControls(this.css3dRenderer.domElement, this.carouselGroup, this.threejsContainer.nativeElement);
        this.objectControls.userInteracted$.subscribe({
            next: val => {
                this.userMove = val;
                // Cancel the rotation, if running
                this.rotationSubscription.unsubscribe();
            }
        });
        // Initialize the animation of the inidcation dots
        if (this.autoPlay) {
            this.startDotAnimation(this.activeCarouselElement);
        }
        // Animate
        this.animate();
    }
    ngOnChanges(changes) {
        let change = changes['activeCarouselElement'];
        if (change && !change.firstChange && this.carouselGroup) {
            this.rotateTo(change.currentValue, true);
        }
        change = changes['radius'];
        if (change && !change.firstChange && this.carouselGroup) {
            this.updateRadius();
        }
        change = changes['cameraFov'];
        if (change && !change.firstChange && this.camera) {
            this.camera.fov = this.cameraFov;
            this.camera.updateProjectionMatrix();
        }
        change = changes['cameraDistance'];
        if (change && !change.firstChange && this.camera) {
            this.camera.position.set(0, 0, this.cameraDistance);
            this.camera.updateProjectionMatrix();
        }
        change = changes['autoPlay'];
        if (change && this.carouselGroup) {
            if (change.currentValue === true) {
                this.startDotAnimation(this.activeCarouselElement);
            }
            else {
                this.resetDotAnimation();
            }
        }
    }
    ngOnDestroy() {
        // Cancel Animation
        cancelAnimationFrame(this.animationFrameId);
        // Unsubscribe Subscriptions
        this.rotationSubscription.unsubscribe();
        // Remove threejs container from DOM
        this.threejsContainer.nativeElement.removeChild(this.css3dRenderer.domElement);
        // Clear scene
        this.scene.clear();
    }
    /**
     * Resizes the canvas and updates the texture resulution information of the images
     */
    resize() {
        // Get width and heigh of the threejs dom element after window resize
        const divWidth = this.threejsContainer.nativeElement.clientWidth;
        const divHeight = this.threejsContainer.nativeElement.clientHeight;
        // Define aspect ratio
        this.camera.aspect = divWidth / divHeight;
        this.camera.updateProjectionMatrix();
        this.css3dRenderer.setSize(divWidth, divHeight);
    }
    /**
     * Animation
     */
    animate() {
        // Only render if the animation flat is true
        if (this.animation == true) {
            this.css3dRenderer.render(this.scene, this.camera);
        }
        if (this.performanceMonitor && this.showPerformanceMonitor) {
            this.performanceMonitor.end();
        }
        this.ngZone.runOutsideAngular(() => {
            this.animationFrameId = window.requestAnimationFrame(() => this.animate());
        });
    }
    /**
     * starts the animation of the indication dots
     * @param index index number for which dot the animation should be started
     * @returns
     */
    startDotAnimation(index) {
        if (this.dotAnimationPlayer || !this.dots) {
            // Animation is already ongoing
            return;
        }
        // Define the animation
        let autoPlayAnimation;
        if (this.showDots) {
            autoPlayAnimation = this.animationBuilder.build([
                style({ strokeDasharray: '0,250.2', visibility: 'visible' }),
                animate(this.autoPlayInterval, style({ strokeDasharray: '250.2,250.2', visibility: 'hidden' }))
            ]);
        }
        else {
            autoPlayAnimation = this.animationBuilder.build([
                style({ strokeDasharray: '0,250.2', visibility: 'hidden' }),
                animate(this.autoPlayInterval, style({ strokeDasharray: '250.2,250.2', visibility: 'hidden' }))
            ]);
        }
        // Get the element for, which the animation should be applied
        const path = this.dots.nativeElement.children[index].getElementsByTagName('path')[0];
        this.dotAnimationPlayer = autoPlayAnimation.create(path);
        // Start the animation
        this.dotAnimationPlayer.play();
        // Switch to the next carousel, as soon as the animation is finished
        this.dotAnimationPlayer.onDone(() => {
            this.dotAnimationPlayer = null;
            this.next();
        });
    }
    /**
     * Resets the dot animation
     */
    resetDotAnimation() {
        if (this.dotAnimationPlayer && this.dotAnimationPlayer.hasStarted()) {
            this.dotAnimationPlayer.reset();
            this.dotAnimationPlayer = null;
        }
    }
    /**
     * Initialize the carousel objects
     */
    initCarouselObjects(animation = true) {
        this.carouselElements = new Array();
        for (let idx = 0; idx < this.carouselItemTemplates.length; idx++) {
            let copiedElement = (this.carouselItemTemplates.get(idx)?.htmlElement);
            if (copiedElement) {
                var object = new CSS3DObject(copiedElement);
                object.element.style.pointerEvents = 'none';
                // Add element to global variable
                this.carouselElements.push(object);
                // Create subscription for tween animation
                this.carouselObjSubsciptions.push(new Subscription());
            }
        }
        // Clear the carousel group
        this.carouselGroup.clear();
        var yOrientation = -((this.activeCarouselElement) * Math.PI * 2 / this.carouselElements.length);
        this.carouselGroup.rotation.set(0, yOrientation, 0);
        var index = 0;
        const elementsCnt = this.carouselElements.length;
        this.carouselElements.forEach(obj => {
            // Unsubscribe previously subscription
            this.carouselObjSubsciptions[index].unsubscribe();
            // Define final position
            let tweenObj = new Object3D();
            let theta = index * 2 * (Math.PI / elementsCnt);
            tweenObj.position.setFromCylindricalCoords(this.radius, theta, this.yPosition);
            let vector = new Vector3(tweenObj.position.x * 2, tweenObj.position.y, tweenObj.position.z * 2);
            tweenObj.lookAt(vector);
            // Set roattion
            obj.rotation.x = tweenObj.rotation.x;
            obj.rotation.y = tweenObj.rotation.y;
            obj.rotation.z = tweenObj.rotation.z;
            if (this.initAnimation === true && animation === true) {
                // Set random position
                obj.position.x = Math.random() * 2000 - 1000;
                obj.position.y = Math.random() * 500;
                obj.position.z = Math.random() * 500;
                // Add the objects to the portfolio group
                this.carouselGroup.add(obj);
                // Tween to final position
                this.ngZone.runOutsideAngular(() => {
                    this.carouselObjSubsciptions[index] = RxjsTween.createTween(RxjsTween.easeInOutQuad, [obj.position.x, obj.position.y, obj.position.z], [tweenObj.position.x, tweenObj.position.y, tweenObj.position.z], 2000).subscribe({
                        next: tweenPos => {
                            obj.position.set(tweenPos[0], tweenPos[1], tweenPos[2]);
                        }
                    });
                });
            }
            else {
                obj.position.x = tweenObj.position.x;
                obj.position.y = tweenObj.position.y;
                obj.position.z = tweenObj.position.z;
                // Add the objects to the portfolio group
                this.carouselGroup.add(obj);
            }
            index = index + 1;
        });
        //add the group to the scene
        this.scene.add(this.carouselGroup);
    }
    /**
     * Rotate to next carousel item
     * @returns Promise with the new active element number
     */
    next() {
        let nextElement = this.activeCarouselElement >= this.carouselElements.length - 1 ? 0 : this.activeCarouselElement + 1;
        return this.rotateTo(nextElement);
    }
    /**
     * Rotate to previous carousel item#
     * @returns Promise with the new active element number
     */
    previous() {
        let nextElement = this.activeCarouselElement == 0 ? this.carouselElements.length - 1 : this.activeCarouselElement - 1;
        return this.rotateTo(nextElement);
    }
    /**
     * Rotates to a sepcific carousel item
     * @param targetIndex index of the carousel item
     */
    rotateTo(targetIndex, skipAnimation = false) {
        return new Promise((resolve, reject) => {
            if (targetIndex > this.carouselElements.length - 1) {
                console.error('target index is greater than available carousel items');
                reject('target index is greater than available carousel items');
            }
            this.resetDotAnimation();
            if (targetIndex > this.activeCarouselElement) {
                // In case the current elment is the first again, reset the orientation
                if (this.activeCarouselElement == 0 && (this.carouselGroup.rotation.y != 0
                    && this.carouselGroup.rotation.x == 0 && this.carouselGroup.rotation.z == 0)) {
                    this.carouselGroup.rotation.set(0, 0, 0);
                }
            }
            else if (targetIndex == this.carouselElements.length - 1) {
                // Set position of the first element to y = -2*PI
                if (this.activeCarouselElement == 0 && (this.carouselGroup.rotation.y == 0
                    && this.carouselGroup.rotation.x == 0 && this.carouselGroup.rotation.z == 0)) {
                    this.carouselGroup.rotation.set(0, -2 * Math.PI, 0);
                }
            }
            const startQuaternion = this.carouselGroup.quaternion.clone();
            // Calculate the orientation of the target item
            const yOrientation = -((targetIndex) * Math.PI * 2 / this.carouselElements.length);
            let targetQuaternion = new Quaternion().setFromEuler(new Euler(0, yOrientation, 0, 'XYZ'));
            if (skipAnimation) {
                this.carouselGroup.quaternion.slerpQuaternions(startQuaternion, targetQuaternion, 1);
                this.rotationCompleted(targetIndex);
                resolve(this.activeCarouselElement);
            }
            else {
                this.rotationSubscription.unsubscribe();
                // Run rotation animation outsie zgZone
                this.ngZone.runOutsideAngular(() => {
                    this.rotationSubscription = RxjsTween.createTween(RxjsTween.easeInOutQuad, 0, 1, this.rotationDuration).subscribe({
                        next: x => {
                            this.carouselGroup.quaternion.slerpQuaternions(startQuaternion, targetQuaternion, x);
                        },
                        complete: () => {
                            this.carouselGroup.quaternion.slerpQuaternions(startQuaternion, targetQuaternion, 1);
                            this.ngZone.run(() => {
                                this.rotationCompleted(targetIndex);
                                resolve(this.activeCarouselElement);
                            });
                        }
                    });
                });
            }
        });
    }
    /**
     * things to do when rotation is completed
     * @param targetIndex
     */
    rotationCompleted(targetIndex) {
        this.activeCarouselElement = targetIndex;
        this.activeElementChanged.emit(this.activeCarouselElement);
        this.objectControls.resetUserInteractionFlag();
        if (this.autoPlay) {
            this.startDotAnimation(this.activeCarouselElement);
        }
    }
    /**
     * Updates and reinits the carousel items
     */
    updateCarouselItems() {
        this.initCarouselObjects(false);
    }
    /**
     * Updates the radius of the carousel items
     */
    updateRadius() {
        for (let idx = 0; idx < this.carouselGroup.children.length; idx++) {
            let theta = idx * 2 * (Math.PI / this.carouselGroup.children.length);
            this.carouselGroup.children[idx].position.setFromCylindricalCoords(this.radius, theta, this.yPosition);
        }
    }
}
CarouselComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: CarouselComponent, deps: [{ token: i0.NgZone }, { token: i1$1.AnimationBuilder }], target: i0.ɵɵFactoryTarget.Component });
CarouselComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.1", type: CarouselComponent, selector: "acuw-carousel", inputs: { showDots: "showDots", dotColor: "dotColor", activeDotColor: "activeDotColor", dotAnimationCircleColor: "dotAnimationCircleColor", activeCarouselElement: "activeCarouselElement", initAnimation: "initAnimation", radius: "radius", yPosition: "yPosition", cameraFov: "cameraFov", cameraDistance: "cameraDistance", autoPlay: "autoPlay", autoPlayInterval: "autoPlayInterval", rotationDuration: "rotationDuration", showPerformanceMonitor: "showPerformanceMonitor" }, outputs: { activeElementChanged: "activeElementChanged" }, host: { listeners: { "window:resize": "resize()" } }, queries: [{ propertyName: "carouselItemTemplates", predicate: CarouselItem }], viewQueries: [{ propertyName: "threejsContainer", first: true, predicate: ["threejsContainer"], descendants: true }, { propertyName: "dots", first: true, predicate: ["indicationDots"], descendants: true }, { propertyName: "performanceMonitor", first: true, predicate: ["performanceMonitor"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div class="carousel-container">
      <div #threejsContainer class="threejs-container"></div>
      <!-- dots -->
      <div #indicationDots class="dots" [ngStyle]="{'visibility': showDots ? 'visible' : 'hidden'}">
        <svg *ngFor="let carouselTemplate of carouselItemTemplates; index as i" viewBox="0 0 100 100">
            <circle cx="50" cy="50" r="45" [ngStyle]="{'fill': activeCarouselElement===i ? activeDotColor : dotColor}"/>
            <path id="{{i}}" fill="none" stroke-linecap="round" stroke-width="20" 
            [ngStyle]="{'stroke': dotAnimationCircleColor, 'visibility': activeCarouselElement===i && autoPlay ? 'visible' : 'hidden'}"
                  d="M50 10 a 40 40 0 0 1 0 80 a 40 40 0 0 1 0 -80"/>
          </svg>
      </div>
     <acuw-performance-monitor *ngIf="showPerformanceMonitor" #performanceMonitor></acuw-performance-monitor>
    </div>
    
  `, isInline: true, styles: [".carousel-container{position:relative;width:100%;height:100%;background-color:inherit}.threejs-container{position:relative;display:flex;justify-content:center;align-items:center;width:100%;height:100%;background-color:inherit}.dots{position:absolute;bottom:0%;display:flex;flex-direction:row;justify-content:center;flex-wrap:wrap;width:100%;overflow:hidden}.dots svg{width:28px;height:28px;margin:0 5px 24px}\n"], components: [{ type: PerformanceMonitorComponent, selector: "acuw-performance-monitor" }], directives: [{ type: i2.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], animations: [
        trigger('dotsAnimation', [
            transition(':enter', [
                query('svg', [
                    style({ opacity: 0, transform: 'translateY(200%)' }),
                    stagger(100, [
                        animate('300ms ease-in', style({ opacity: 1, transform: 'none' }))
                    ])
                ], { optional: true })
            ]),
            transition(':leave', [
                query('svg', [
                    stagger(100, [
                        animate('300ms ease-in', style({ opacity: 0, transform: 'translateY(200%)' }))
                    ])
                ], { optional: true })
            ])
        ]),
        trigger('autoPlayAnimation', [
            state('false', style({ strokeDasharray: '0,250.2' })),
            state('true', style({ strokeDasharray: '250.2,250.2' })),
            transition('false => true', animate(5000))
        ])
    ] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: CarouselComponent, decorators: [{
            type: Component,
            args: [{ selector: 'acuw-carousel', template: `
    <div class="carousel-container">
      <div #threejsContainer class="threejs-container"></div>
      <!-- dots -->
      <div #indicationDots class="dots" [ngStyle]="{'visibility': showDots ? 'visible' : 'hidden'}">
        <svg *ngFor="let carouselTemplate of carouselItemTemplates; index as i" viewBox="0 0 100 100">
            <circle cx="50" cy="50" r="45" [ngStyle]="{'fill': activeCarouselElement===i ? activeDotColor : dotColor}"/>
            <path id="{{i}}" fill="none" stroke-linecap="round" stroke-width="20" 
            [ngStyle]="{'stroke': dotAnimationCircleColor, 'visibility': activeCarouselElement===i && autoPlay ? 'visible' : 'hidden'}"
                  d="M50 10 a 40 40 0 0 1 0 80 a 40 40 0 0 1 0 -80"/>
          </svg>
      </div>
     <acuw-performance-monitor *ngIf="showPerformanceMonitor" #performanceMonitor></acuw-performance-monitor>
    </div>
    
  `, animations: [
                        trigger('dotsAnimation', [
                            transition(':enter', [
                                query('svg', [
                                    style({ opacity: 0, transform: 'translateY(200%)' }),
                                    stagger(100, [
                                        animate('300ms ease-in', style({ opacity: 1, transform: 'none' }))
                                    ])
                                ], { optional: true })
                            ]),
                            transition(':leave', [
                                query('svg', [
                                    stagger(100, [
                                        animate('300ms ease-in', style({ opacity: 0, transform: 'translateY(200%)' }))
                                    ])
                                ], { optional: true })
                            ])
                        ]),
                        trigger('autoPlayAnimation', [
                            state('false', style({ strokeDasharray: '0,250.2' })),
                            state('true', style({ strokeDasharray: '250.2,250.2' })),
                            transition('false => true', animate(5000))
                        ])
                    ], styles: [".carousel-container{position:relative;width:100%;height:100%;background-color:inherit}.threejs-container{position:relative;display:flex;justify-content:center;align-items:center;width:100%;height:100%;background-color:inherit}.dots{position:absolute;bottom:0%;display:flex;flex-direction:row;justify-content:center;flex-wrap:wrap;width:100%;overflow:hidden}.dots svg{width:28px;height:28px;margin:0 5px 24px}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: i1$1.AnimationBuilder }]; }, propDecorators: { showDots: [{
                type: Input
            }], dotColor: [{
                type: Input
            }], activeDotColor: [{
                type: Input
            }], dotAnimationCircleColor: [{
                type: Input
            }], activeCarouselElement: [{
                type: Input
            }], initAnimation: [{
                type: Input
            }], radius: [{
                type: Input
            }], yPosition: [{
                type: Input
            }], cameraFov: [{
                type: Input
            }], cameraDistance: [{
                type: Input
            }], autoPlay: [{
                type: Input
            }], autoPlayInterval: [{
                type: Input
            }], rotationDuration: [{
                type: Input
            }], showPerformanceMonitor: [{
                type: Input
            }], activeElementChanged: [{
                type: Output
            }], threejsContainer: [{
                type: ViewChild,
                args: ['threejsContainer']
            }], dots: [{
                type: ViewChild,
                args: ['indicationDots']
            }], performanceMonitor: [{
                type: ViewChild,
                args: ['performanceMonitor']
            }], carouselItemTemplates: [{
                type: ContentChildren,
                args: [CarouselItem]
            }], resize: [{
                type: HostListener,
                args: ['window:resize']
            }] } });

class CarouselModule {
}
CarouselModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: CarouselModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CarouselModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: CarouselModule, declarations: [CarouselComponent, CarouselItem], imports: [CommonModule,
        PerformanceMonitorModule], exports: [CarouselComponent, CarouselItem] });
CarouselModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: CarouselModule, imports: [[
            CommonModule,
            PerformanceMonitorModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: CarouselModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [CarouselComponent, CarouselItem],
                    imports: [
                        CommonModule,
                        PerformanceMonitorModule
                    ],
                    exports: [CarouselComponent, CarouselItem]
                }]
        }] });

/*
 * Public API Surface of ngx-acuw
 */

/**
 * Generated bundle index. Do not edit.
 */

export { CarouselComponent, CarouselItem, CarouselModule, ImageAsParticlesComponent, ImageAsParticlesModule, ImageTransitionComponent, ImageTransitionModule, LightboxComponent, LightboxModule, PerformanceMonitorComponent, PerformanceMonitorModule };
//# sourceMappingURL=ngx-acuw.mjs.map
